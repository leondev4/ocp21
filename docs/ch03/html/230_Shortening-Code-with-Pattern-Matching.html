<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<title>Markmap</title>
<style>
* {
  margin: 0;
  padding: 0;
}
#mindmap {
  display: block;
  width: 100vw;
  height: 100vh;
}
</style>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@highlightjs/cdn-assets@11.11.1/styles/default.min.css">
</head>
<body>
<svg id="mindmap"></svg>
<script src="https://cdn.jsdelivr.net/npm/d3@7.9.0/dist/d3.min.js"></script><script src="https://cdn.jsdelivr.net/npm/markmap-view@0.18.10/dist/browser/index.js"></script><script src="https://cdn.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/index.js"></script><script>(r => {
              setTimeout(r);
            })(function renderToolbar() {
  const {
    markmap,
    mm
  } = window;
  const {
    el
  } = markmap.Toolbar.create(mm);
  el.setAttribute('style', 'position:absolute;bottom:20px;right:20px');
  document.body.append(el);
})</script><script>((getMarkmap, getOptions, root2, jsonOptions) => {
              const markmap = getMarkmap();
              window.mm = markmap.Markmap.create(
                "svg#mindmap",
                (getOptions || markmap.deriveOptions)(jsonOptions),
                root2
              );
            })(() => window.markmap,null,{"content":"<strong>Shortening Code with <br> Pattern Matching</strong>","children":[{"content":"<em>Pattern matching</em> is a technique of controlling program flow that only<br>\nexecutes a section of code that meets certain criteria. We perform<br>\npattern matching with the <code>if</code> statement, along with the <code>instanceof</code><br>\noperator, to improve program control.","children":[{"content":"Pattern matching is a useful tool for reducing boilerplate<br>\ncode in your application. <em>Boilerplate</em> code is code that tends<br>\nto be duplicated throughout a section of code over and over<br>\nagain in a similar manner.","children":[{"content":"To understand why this feature was added, consider the following code<br>\nthat takes a <code>Number</code> instance and compares it with the value <code>5</code>. You just<br>\nneed to know that <code>Integer</code> inherits from <code>Number</code>.","children":[{"content":"\n<pre data-lines=\"17,25\"><code class=\"language-java\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">compareIntegers</span><span class=\"hljs-params\">(Number number)</span> {\n  <span class=\"hljs-keyword\">if</span>(number <span class=\"hljs-keyword\">instanceof</span> Integer) {\n    <span class=\"hljs-type\">Integer</span> <span class=\"hljs-variable\">data</span> <span class=\"hljs-operator\">=</span>(Integer)number;\n    System.out.print(data.compareTo(<span class=\"hljs-number\">5</span>));\n  }\n}\n</code></pre>","children":[{"content":"The cast is needed since the <code>compareTo()</code> method<br>\nis defined on <code>Integer</code>, but not on <code>Number</code>.","children":[],"payload":{"tag":"li","lines":"25,27"}}],"payload":{"tag":"li","lines":"17,27"}}],"payload":{"tag":"li","lines":"14,27"}}],"payload":{"tag":"li","lines":"10,27"}}],"payload":{"tag":"li","lines":"6,27"}},{"content":"Code that first checks if a variable is of a particular type and then<br>\nimmediately casts it to that type is extremely common in the Java<br>\nworld. It&#x2019;s so common that the authors of Java decided to implement<br>\na shorter syntax for it:","children":[{"content":"\n<pre data-lines=\"31,38\"><code class=\"language-java\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">compareIntegers</span><span class=\"hljs-params\">(Number number)</span> {\n  <span class=\"hljs-keyword\">if</span>(number <span class=\"hljs-keyword\">instanceof</span> Integer data ){\n    System.out.print(data.compareTo(<span class=\"hljs-number\">5</span>));\n  }\n}\n</code></pre>","children":[{"content":"The variable <code>data</code> in this example is referred to as the<br>\n<strong>pattern variable</strong>. Notice that this code also avoids any<br>\npotential <code>ClassCastException</code> because the cast operation<br>\nis executed only if the <code>instanceof</code> operator returns <code>true</code>.","children":[{"content":"<a href=\"https://1drv.ms/i/c/c83cfca51d5c2032/EQPN6t4VJH1Jr1D6HVmTn3EB6M-OLAiC1st9dyxllhzL8g?e=Ooj5uL\">Figure 3.3</a> shows the anatomy of pattern matching using the <code>instanceof</code><br>\noperator and <code>if</code> statements. Adding a variable after the type is what<br>\ninstructs the compiler to treat it as pattern matching. The Figure also<br>\nshows an optional conditional clause.","children":[{"content":"\n<p data-lines=\"46,48\"><strong>Reassigning Pattern Variables</strong><br>\nWhile possible, it is a bad practice.</p>\n<pre data-lines=\"49,54\"><code class=\"language-java\"><span class=\"hljs-keyword\">if</span>(number <span class=\"hljs-keyword\">instanceof</span> Integer data) {\n  data = <span class=\"hljs-number\">10</span>;\n}\n</code></pre>\n<p data-lines=\"54,56\">The reassignment can be prevented with a <code>final</code><br>\nmodifier.</p>\n<pre data-lines=\"56,61\"><code class=\"language-java\"><span class=\"hljs-keyword\">if</span>(number <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-keyword\">final</span> Integer data){\n  data = <span class=\"hljs-number\">10</span>; <span class=\"hljs-comment\">// DOES NOT COMPILE</span>\n}\n</code></pre>","children":[],"payload":{"tag":"li","lines":"46,61"}}],"payload":{"tag":"li","lines":"42,61"}}],"payload":{"tag":"li","lines":"38,61"}}],"payload":{"tag":"li","lines":"31,61"}}],"payload":{"tag":"li","lines":"27,61"}},{"content":"<strong>Pattern Variables and Expressions</strong><br>\nPattern matching supports an optional <code>boolean</code><br>\nexpression. This can be used to filter data out.","children":[{"content":"\n<pre data-lines=\"64,70\"><code class=\"language-java\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">printIntegersGreaterThan5</span><span class=\"hljs-params\">(Number number)</span>{\n  <span class=\"hljs-keyword\">if</span>(number <span class=\"hljs-keyword\">instanceof</span> Integer data &amp;&amp; data.compareTo(<span class=\"hljs-number\">5</span>) &gt; <span class=\"hljs-number\">0</span>)\n    System.out.print(data);\n}\n</code></pre>","children":[{"content":"We can apply a number of filters, or patterns, so that the <code>if</code> statement  is executed<br>\nonly in specific circumstances. <strong>Notice that we&#x2019;re using  the pattern variable<br>\nin an expression in the same line in which it is declared.</strong>","children":[{"content":"<strong>Pattern Matching with <code>null</code></strong><br>\nThe <code>instanceof</code> operator always evaluates <code>null</code> references<br>\nto <code>false</code>. The same holds for pattern matching.","children":[{"content":"\n<pre data-lines=\"76,88\"><code class=\"language-java\"><span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">noObjectHere</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">null</span>;\n\n<span class=\"hljs-keyword\">if</span>(noObjectHere <span class=\"hljs-keyword\">instanceof</span> String)\n    System.out.println(<span class=\"hljs-string\">&quot;Not printed&quot;</span>);\n\n<span class=\"hljs-keyword\">if</span>(noObjectHere <span class=\"hljs-keyword\">instanceof</span> String s)\n    System.out.println(<span class=\"hljs-string\">&quot;Still not printed&quot;</span>);\n\n<span class=\"hljs-keyword\">if</span>(noObjectHere <span class=\"hljs-keyword\">instanceof</span> String s &amp;&amp; s.length() &gt; -<span class=\"hljs-number\">1</span>)\n  System.out.println(<span class=\"hljs-string\">&quot;Nope, not this one either&quot;</span>);\n</code></pre>","children":[],"payload":{"tag":"li","lines":"76,88"}}],"payload":{"tag":"li","lines":"73,88"}},{"content":"As shown in the last example, this also helps avoid any potential <code>NullPointerException</code>,<br>\nas the conditional operator (<code>&amp;&amp;</code>, short-circuit) causes the <code>s.length()</code> call to be skipped.","children":[],"payload":{"tag":"li","lines":"88,90"}}],"payload":{"tag":"li","lines":"70,90"}}],"payload":{"tag":"li","lines":"64,90"}}],"payload":{"tag":"li","lines":"61,90"}},{"content":"<strong>Supported Types</strong><br>\nThe type of the pattern variable must be a compatible type,<br>\nwhich includes the <strong>same type, a subtype, or a supertype<br>\nof the reference variable. If the reference variable does<br>\nnot refer to a <code>final</code> class or type, then it can also<br>\ninclude an unrelated interface.</strong>","children":[{"content":"Consider the following two examples, in which<br>\n<code>Integer</code> is a subtype of <code>Number</code>:","children":[{"content":"\n<pre data-lines=\"98,107\"><code class=\"language-java\"><span class=\"hljs-number\">11</span>: <span class=\"hljs-type\">Number</span> <span class=\"hljs-variable\">bearHeight</span> <span class=\"hljs-operator\">=</span> Integer.valueOf(<span class=\"hljs-number\">123</span>);\n<span class=\"hljs-number\">12</span>:\n<span class=\"hljs-number\">13</span>: <span class=\"hljs-keyword\">if</span> (bearHeight <span class=\"hljs-keyword\">instanceof</span> Integer i){}\n<span class=\"hljs-number\">14</span>: <span class=\"hljs-keyword\">if</span> (bearHeight <span class=\"hljs-keyword\">instanceof</span> Number n){}\n<span class=\"hljs-number\">15</span>: <span class=\"hljs-keyword\">if</span> (bearHeight <span class=\"hljs-keyword\">instanceof</span> String s){} <span class=\"hljs-comment\">// DOES NOT COMPILE</span>\n<span class=\"hljs-number\">16</span>: <span class=\"hljs-keyword\">if</span> (bearHeight <span class=\"hljs-keyword\">instanceof</span> Object o){}\n<span class=\"hljs-number\">17</span>: <span class=\"hljs-keyword\">if</span> (bearHeight <span class=\"hljs-keyword\">instanceof</span> Cloneable c) {}\n</code></pre>","children":[{"content":"The first example uses a subtype, while the second example uses the same type as the reference variable<br>\n<code>bearHeight</code>. On line <code>15</code>, the compiler recognizes that a <code>Number</code> cannot be cast to an unrelated type<br>\n<code>String</code> and throws an error. Line 16 is permitted but not particularly useful, since every <code>Object</code> except<br>\n<code>null</code> will return <code>true</code>.<br>\nApplies to the line 17: If the reference variable does not refer to a <code>final</code> class or type, it can also include an<br>\nunrelated interface.","children":[],"payload":{"tag":"li","lines":"107,113"}}],"payload":{"tag":"li","lines":"98,113"}}],"payload":{"tag":"li","lines":"96,113"}}],"payload":{"tag":"li","lines":"90,113"}},{"content":"<strong>Flow Scoping</strong><br>\nFlow scoping means the variable is only in scope when the<br>\ncompiler can definitively determine its type. Flow scoping<br>\nis unlike any other type of scoping, in that it is not strictly<br>\nhierarchical. It is determined by the compiler based on the<br>\nbranching and flow of the program.","children":[{"content":"\n<pre data-lines=\"119,125\"><code class=\"language-java\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">printIntegersOrNumbersGreaterThan5</span><span class=\"hljs-params\">(Number number)</span> {\n  <span class=\"hljs-keyword\">if</span>(number <span class=\"hljs-keyword\">instanceof</span> Integer data || data.compareTo(<span class=\"hljs-number\">5</span>) &gt; <span class=\"hljs-number\">0</span>)\n    System.out.print(data);\n}\n</code></pre>","children":[{"content":"The key thing to notice is that we used OR (<code>||</code>) not AND (<code>&amp;&amp;</code>) in the<br>\nconditional statement. If the input does not inherit <code>Integer</code>, the <code>data</code><br>\nvariable is undefined. Since the compiler cannot guarantee that<br>\n<code>data</code> is an instance of <code>Integer</code>, the code does not compile.","children":[{"content":"\n<pre data-lines=\"129,136\"><code class=\"language-java\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">printIntegerTwice</span><span class=\"hljs-params\">(Number number)</span> {\n  <span class=\"hljs-keyword\">if</span>(number <span class=\"hljs-keyword\">instanceof</span> Integer data)\n    System.out.print(data.intValue());\n    <span class=\"hljs-type\">var</span> <span class=\"hljs-variable\">n</span> <span class=\"hljs-operator\">=</span>data.intValue(); <span class=\"hljs-comment\">// DOES NOT COMPILE</span>\n}\n</code></pre>","children":[{"content":"Since the input might not have inherited <code>Integer</code>, <code>data</code> is no<br>\nlonger in scope after the <code>if</code> statement.","children":[],"payload":{"tag":"li","lines":"136,138"}}],"payload":{"tag":"li","lines":"129,138"}}],"payload":{"tag":"li","lines":"125,138"}}],"payload":{"tag":"li","lines":"119,138"}}],"payload":{"tag":"li","lines":"113,138"}},{"content":"Consider the following example that does compile:<pre data-lines=\"139,146\"><code class=\"language-java\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">printOnlyIntegers</span><span class=\"hljs-params\">(Number number)</span> {\n  <span class=\"hljs-keyword\">if</span>(!(number <span class=\"hljs-keyword\">instanceof</span> Integer data))\n    <span class=\"hljs-keyword\">return</span>;\n  <span class=\"hljs-type\">var</span> <span class=\"hljs-variable\">n</span> <span class=\"hljs-operator\">=</span>data.intValue();\n}\n</code></pre>","children":[{"content":"It might surprise you to learn this code does compile. The<br>\nmethod returns if the input does not inherit <code>Integer</code>. This<br>\nmeans that when the last line of the method is reached,<br>\nthe input must inherit <code>Integer</code>, and therefore <code>data</code><br>\nstays in scope even after the <code>if</code> statement ends.","children":[{"content":"<strong>Flow Scoping and <code>else</code> Branches</strong>","children":[{"content":"Another way to think about it is to rewrite the<br>\nlogic to something equivalent that uses an <code>else</code><br>\nstatement:","children":[{"content":"\n<pre data-lines=\"155,163\"><code class=\"language-java\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">printOnlyIntegers</span><span class=\"hljs-params\">(Number number)</span> {\n  <span class=\"hljs-keyword\">if</span>(!(number <span class=\"hljs-keyword\">instanceof</span> Integer data))\n    <span class=\"hljs-keyword\">return</span>;\n  <span class=\"hljs-keyword\">else</span>\n    System.out.print(data.intValue());\n}\n</code></pre>","children":[],"payload":{"tag":"li","lines":"155,163"}}],"payload":{"tag":"li","lines":"152,163"}},{"content":"We can now go one step further and reverse the <code>if</code> and<br>\n<code>else</code> branches by inverting the <code>boolean</code> expression:","children":[{"content":"\n<pre data-lines=\"165,173\"><code class=\"language-java\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">printOnlyIntegers</span><span class=\"hljs-params\">(Number number)</span> {\n  <span class=\"hljs-keyword\">if</span>(number <span class=\"hljs-keyword\">instanceof</span> Integer data)\n    System.out.print(data.intValue());\n  <span class=\"hljs-keyword\">else</span>\n    <span class=\"hljs-keyword\">return</span>;\n}\n</code></pre>","children":[{"content":"Our new code is equivalent to our original and better demonstrates<br>\nhow the compiler was able to determine that <code>data</code> was in scope<br>\nonly when <code>number</code> is an <code>Integer</code>.","children":[],"payload":{"tag":"li","lines":"173,176"}}],"payload":{"tag":"li","lines":"165,176"}}],"payload":{"tag":"li","lines":"163,176"}}],"payload":{"tag":"li","lines":"151,176"}}],"payload":{"tag":"li","lines":"146,176"}}],"payload":{"tag":"li","lines":"138,176"}}],"payload":{"tag":"h1","lines":"5,6"}},{"initialExpandLevel":1})</script>
</body>
</html>
