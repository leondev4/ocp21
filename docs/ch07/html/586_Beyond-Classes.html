<!doctype html>
<html>
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta http-equiv="X-UA-Compatible" content="ie=edge" />
<title>Markmap</title>
<style>
* {
  margin: 0;
  padding: 0;
}
html {
  font-family: ui-sans-serif, system-ui, sans-serif, 'Apple Color Emoji',
    'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji';
}
#mindmap {
  display: block;
  width: 100vw;
  height: 100vh;
}
.markmap-dark {
  background: #27272a;
  color: white;
}
</style>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/markmap-toolbar@0.18.12/dist/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@highlightjs/cdn-assets@11.11.1/styles/default.min.css">
</head>
<body>
<svg id="mindmap"></svg>
<script src="https://cdn.jsdelivr.net/npm/d3@7.9.0/dist/d3.min.js"></script><script src="https://cdn.jsdelivr.net/npm/markmap-view@0.18.12/dist/browser/index.js"></script><script src="https://cdn.jsdelivr.net/npm/markmap-toolbar@0.18.12/dist/index.js"></script><script>(r => {
              setTimeout(r);
            })(function renderToolbar() {
  const {
    markmap,
    mm
  } = window;
  const {
    el
  } = markmap.Toolbar.create(mm);
  el.setAttribute('style', 'position:absolute;bottom:20px;right:20px');
  document.body.append(el);
})</script><script>((getMarkmap, getOptions, root2, jsonOptions) => {
              const markmap = getMarkmap();
              window.mm = markmap.Markmap.create(
                "svg#mindmap",
                (getOptions || markmap.deriveOptions)(jsonOptions),
                root2
              );
              if (window.matchMedia("(prefers-color-scheme: dark)").matches) {
                document.documentElement.classList.add("markmap-dark");
              }
            })(() => window.markmap,null,{"content":"<strong>Beyond Classes</strong>","children":[{"content":"For this chapter, remember that a Java file may have at most one public top-level type,<br>\nand it must match the name of the file. This applies to classes, enums, records, and so<br>\non. Also, remember that a top-level type can only be declared with <code>public</code> or package<br>\naccess.","children":[{"content":"<strong>Annotations to Know for the Exam</strong><br>\n<code>@Override</code>, <code>@FunctionalInterface</code>, <code>@Deprecated</code>, <code>@SuppressWarnings</code> and <code>@SafeVarargs</code>","children":[{"content":"<strong>Implementing Interfaces</strong><br>\nSince classes can only extend one class, they had limited use for inheritance.<br>\nOn the other hand, a class may implement any number of interfaces. An interface<br>\nis an abstract data type that declares a list of abstract methods that any class<br>\nimplementing the interface must provide.","children":[{"content":"<strong>Declaring and Using an Interface</strong><br>\nIn Java, an interface is defined with the <code>interface</code> keyword, analogous to the <code>class</code> keyword<br>\nused when defining a class. Refer to <a href=\"https://1drv.ms/i/c/c83cfca51d5c2032/EXbRTA5UmA1HhxowAViWnMsBKXKM0pvtBQnftetspEXaWA?e=PKTFjA\">Figure 7.1</a> for a proper interface declaration.","children":[{"content":"In Figure 7.1, our interface declaration includes a single abstract method and a constant<br>\nvariable. <strong>Interface variables</strong> are referred to as constants because they <strong>are assumed to<br>\nbe <code>public</code>, <code>static</code>, and <code>final</code>.</strong> They are initialized with a constant value when they are<br>\ndeclared. Since they are <code>public</code> and <code>static</code>, they can be used outside the interface<br>\ndeclaration without requiring an instance of the interface. Figure 7.1 also includes an<br>\n<strong>abstract method</strong> that, like an interface variable, <strong>is assumed to be <code>public</code>.</strong>","children":[{"content":"One aspect of an interface declaration that differs from an abstract class is that it contains<br>\nimplicit modifiers. An implicit modifier is a modifier that the compiler automatically inserts<br>\ninto the code. For example, an interface is always considered to be <code>abstract</code>, even if it is<br>\nnot marked so!","children":[],"payload":{"tag":"li","lines":"27,31"}}],"payload":{"tag":"li","lines":"21,31"}}],"payload":{"tag":"li","lines":"18,31"}}],"payload":{"tag":"li","lines":"13,31"}}],"payload":{"tag":"li","lines":"11,31"}}],"payload":{"tag":"li","lines":"7,31"}},{"content":"\n<pre data-lines=\"31,34\"><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">WalksOnTwoLegs</span> {}\n</code></pre>\nIt compiles because interfaces are not required to define any methods. The <code>abstract</code><br>\nmodifier in this example is optional for interfaces, with the compiler inserting it if it is<br>\nnot provided.","children":[{"content":"Consider the following two examples:<pre data-lines=\"38,46\"><code class=\"language-java\"><span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">WalksOnEightLegs</span> {} <span class=\"hljs-comment\">// DOES NOT COMPILE</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Biped</span> {\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> {\n    <span class=\"hljs-type\">var</span> <span class=\"hljs-variable\">e</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">WalksOnTwoLegs</span>(); <span class=\"hljs-comment\">// DOES NOT COMPILE</span>\n  }\n}\n</code></pre>\nThe <code>WalksOnEightLegs</code> interface doesn&#x2019;t compile because interfaces cannot be marked as<br>\n<code>final</code> for the same reason that <code>abstract</code> classes cannot be marked as <code>final</code>. Marking an<br>\ninterface <code>final</code> implies no class could ever implement it. The <code>Biped</code> class also doesn&#x2019;t<br>\ncompile, as <code>WalksOnTwoLegs</code> is an interface and cannot be instantiated.","children":[{"content":"Let&#x2019;s say we have an interface <code>Climb</code>, defined as follows:<pre data-lines=\"51,56\"><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">Climb</span> {\n  Number <span class=\"hljs-title function_\">getSpeed</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> age)</span>;\n}\n</code></pre>\nNext, we have a concrete class <code>FieldMouse</code> that implements the Climb interface,<br>\nas shown in <a href=\"https://1drv.ms/i/c/c83cfca51d5c2032/ETNgDAtbAAtAizt3XKyCQm0BCuyWf4ygw86gH1o9Byoikw?e=H62hUU\">Figure 7.2</a>.","children":[{"content":"The <code>FieldMouse</code> class declares that it implements the <code>Climb</code> interface and includes an<br>\noverridden version of <code>getSpeed()</code> inherited from the <code>Climb</code> interface. The <code>@Override</code><br>\nannotation is optional. It serves to let other developers know that the method is inherited.<br>\nThe method <strong>signature</strong> of <code>getSpeed()</code> <strong>matches exactly</strong>, and the <strong>return type is<br>\ncovariant</strong>, since a <code>Float</code> can be implicitly cast to a <code>Number</code>. The access modifier of<br>\nthe interface method is implicitly <code>public</code> in <code>Climb</code>, although the concrete class<br>\n<code>FieldMouse</code> must explicitly declare it.","children":[{"content":"As shown in Figure 7.2, a class can implement multiple interfaces, each separated by<br>\na comma (<code>,</code>). If any of the interfaces define abstract methods, then the concrete class<br>\nis required to override them. In this case, <code>FieldMouse</code> implements the <code>CanBurrow</code><br>\ninterface that we saw in Figure 7.1. In this manner, the class overrides two abstract<br>\nmethods at the same time with one method declaration.","children":[{"content":"<strong>Extending an Interface</strong><br>\nLike a class, an interface can extend another interface<br>\nusing the <code>extends</code> keyword.<pre data-lines=\"73,77\"><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">Nocturnal</span> {}\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">HasBigEyes</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">Nocturnal</span> {}\n</code></pre>","children":[{"content":"Unlike a class, which can extend only one class, an interface can<br>\nextend multiple interfaces.<pre data-lines=\"79,92\"><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">Nocturnal</span> {\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">hunt</span><span class=\"hljs-params\">()</span>;\n}\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">CanFly</span> {\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">flap</span><span class=\"hljs-params\">()</span>;\n}\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">HasBigEyes</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">Nocturnal</span>, CanFly {}\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Owl</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">HasBigEyes</span> {\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">hunt</span><span class=\"hljs-params\">()</span> { <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">5</span>; }\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">flap</span><span class=\"hljs-params\">()</span> { System.out.println(<span class=\"hljs-string\">&quot;Flap!&quot;</span>); }\n}\n</code></pre>","children":[{"content":"The <code>Owl</code> class implements the <code>HasBigEyes</code> interface and must implement the <code>hunt()</code> and<br>\n<code>flap()</code> methods. Extending two interfaces is permitted because interfaces are not initialized<br>\nas part of a class hierarchy. Unlike abstract classes, they do not contain constructors and<br>\nare not part of instance initialization. Interfaces simply define a set of rules and methods<br>\nthat a class implementing them must follow.","children":[],"payload":{"tag":"li","lines":"92,97"}}],"payload":{"tag":"li","lines":"77,97"}}],"payload":{"tag":"li","lines":"70,97"}}],"payload":{"tag":"li","lines":"65,97"}}],"payload":{"tag":"li","lines":"58,97"}}],"payload":{"tag":"li","lines":"50,97"}}],"payload":{"tag":"li","lines":"37,97"}}],"payload":{"tag":"li","lines":"31,97"}},{"content":"<strong>Inheriting an Interface</strong><br>\nLike an abstract class, when a concrete class implements an interface, all of the inherited<br>\nabstract methods must be implemented. How many abstract methods does the concrete<br>\n<code>Swan</code> class inherit?","children":[{"content":"\n<pre data-lines=\"101,115\"><code class=\"language-java\"><span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Animal</span>{  <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">getType</span><span class=\"hljs-params\">()</span>;  }\n\n<span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">Fly</span>{  <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">fly</span><span class=\"hljs-params\">()</span>; }\n\n<span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">Swim</span>{  <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">swim</span><span class=\"hljs-params\">()</span>;  }\n\n<span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Bird</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">Fly</span>{\n  <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-type\">boolean</span> <span class=\"hljs-title function_\">canSwoop</span><span class=\"hljs-params\">()</span>;\n}\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Swan</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">Bird</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">Swim</span>{\n  <span class=\"hljs-comment\">//???</span>\n}\n</code></pre>","children":[{"content":"The concrete <code>Swan</code> class inherits four abstract methods that it must override:<br>\n<code>getType()</code>, <code>canSwoop()</code>, <code>fly()</code>, and <code>swim()</code>.<br>\nLet&#x2019;s take a look at another example involving an abstract class that implements<br>\nan interface:<pre data-lines=\"119,128\"><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">HasTail</span> {  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">getTailLength</span><span class=\"hljs-params\">()</span>;  }\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">HasWhiskers</span> {  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">getNumberOfWhiskers</span><span class=\"hljs-params\">()</span>;  }\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">HarborSeal</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">HasTail</span>, HasWhiskers {}\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">CommonSeal</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">HarborSeal</span> {}<span class=\"hljs-comment\">// DOES NOT COMPILE</span>\n</code></pre>","children":[{"content":"The <code>HarborSeal</code> class compiles because it is <code>abstract</code> and not required to implement<br>\nany of the <code>abstract</code> methods it inherits. The concrete <code>CommonSeal</code> class, though,<br>\nmust override all inherited abstract methods.","children":[{"content":"<strong>Mixing Class and Interface Keywords</strong><br>\nAlthough a class can implement an interface, a class cannot extend an interface. Likewise,<br>\nwhile an interface can extend another interface, an interface cannot implement another<br>\ninterface or inherit a class. The following examples illustrate these principles:<pre data-lines=\"135,141\"><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">CanRun</span> {}\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Cheetah</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">CanRun</span> {} <span class=\"hljs-comment\">// DOES NOT COMPILE</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Hyena</span> {}\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">HasFur</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">Hyena</span> {} <span class=\"hljs-comment\">// DOES NOT COMPILE</span>\n</code></pre>","children":[{"content":"<strong>Inheriting Duplicate Abstract Methods</strong><br>\nJava supports inheriting two abstract methods that have compatible method declarations.<pre data-lines=\"143,154\"><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">Herbivore</span> { <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">eatPlants</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> plantsLeft)</span>; }\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">Omnivore</span> { <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">eatPlants</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> foodRemaining)</span>; }\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Bear</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">Herbivore</span>, Omnivore {\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">eatPlants</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> plants)</span> {\n    System.out.print(<span class=\"hljs-string\">&quot;Eating plants&quot;</span>);\n    <span class=\"hljs-keyword\">return</span> plants - <span class=\"hljs-number\">1</span>;\n  } }\n</code></pre>","children":[{"content":"By compatible, we mean a method can be written that properly overrides both inherited<br>\nmethods: for example, by using covariant return types. Notice that the method parameter<br>\nnames don&#x2019;t need to match, just the type.<br>\nThe following is an example of an incompatible declaration:<pre data-lines=\"158,167\"><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">Herbivore</span> { <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">eatPlants</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> plantsLeft)</span>; }\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">Omnivore</span> { <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">eatPlants</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> foodRemaining)</span>; }\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Tiger</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">Herbivore</span>, Omnivore { <span class=\"hljs-comment\">// DOES NOT COMPILE</span>\n  <span class=\"hljs-comment\">// Doesn&apos;t matter!</span>\n}\n</code></pre>","children":[{"content":"The implementation of <code>Tiger</code> doesn&#x2019;t matter in this case since it&#x2019;s impossible to write a<br>\nversion of <code>Tiger</code> that satisfies both inherited <code>abstract</code> methods. The code does not<br>\ncompile, regardless of what is declared inside the <code>Tiger</code> class.","children":[],"payload":{"tag":"li","lines":"167,170"}}],"payload":{"tag":"li","lines":"154,170"}}],"payload":{"tag":"li","lines":"141,170"}}],"payload":{"tag":"li","lines":"131,170"}}],"payload":{"tag":"li","lines":"128,170"}}],"payload":{"tag":"li","lines":"115,170"}}],"payload":{"tag":"li","lines":"101,170"}}],"payload":{"tag":"li","lines":"97,170"}},{"content":"<strong>Inserting Implicit Modifiers</strong><br>\nAs mentioned earlier, an implicit modifier is one that the compiler will automatically insert.<br>\nIt&#x2019;s reminiscent of the compiler inserting a default no-argument constructor if you do not<br>\ndefine a constructor. You can choose to insert  these implicit modifiers yourself or let the<br>\ncompiler insert them for you.","children":[{"content":"The following list includes the implicit modifiers for  interfaces that you<br>\nneed to know for the exam:<br>\n* Interfaces are implicitly <code>abstract</code>.<br>\n* Interface variables are implicitly <code>public</code>, <code>static</code>, and <code>final</code>.<br>\n* Interface methods without a body are implicitly <code>abstract</code>.<br>\n* Interface methods without the <code>private</code> modifier are implicitly <code>public</code>.","children":[{"content":"The last rule applies to <code>abstract</code>, <code>default</code>, and <code>static</code> interface methods.<br>\nLet&#x2019;s take a look at an example. The following two interface definitions<br>\nare equivalent, as the compiler will convert them both to the second<br>\ndeclaration:","children":[{"content":"\n<pre data-lines=\"185,201\"><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">Soar</span> {\n  <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">MAX_HEIGHT</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">10</span>;\n  <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">boolean</span> <span class=\"hljs-variable\">UNDERWATER</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">true</span>;\n  <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">fly</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> speed)</span>;\n  <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">takeoff</span><span class=\"hljs-params\">()</span>;\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-type\">double</span> <span class=\"hljs-title function_\">dive</span><span class=\"hljs-params\">()</span>;\n}\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">Soar</span> {\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">MAX_HEIGHT</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">10</span>;\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">boolean</span> <span class=\"hljs-variable\">UNDERWATER</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">true</span>;\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">fly</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> speed)</span>;\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">takeoff</span><span class=\"hljs-params\">()</span>;\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-type\">double</span> <span class=\"hljs-title function_\">dive</span><span class=\"hljs-params\">()</span>;\n}\n</code></pre>","children":[{"content":"<strong>Conflicting Modifiers</strong><br>\nIf an abstract method is implicitly <code>public</code>, can it be explicitly marked <code>protected</code> or<br>\n<code>private</code>?<pre data-lines=\"204,210\"><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">Dance</span> {\n  <span class=\"hljs-keyword\">private</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">count</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">4</span>; <span class=\"hljs-comment\">// DOES NOT COMPILE</span>\n  <span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">step</span><span class=\"hljs-params\">()</span>; <span class=\"hljs-comment\">// DOES NOT COMPILE</span>\n}\n</code></pre>\nNeither of these interface member declarations compiles, as the compiler will<br>\napply the <code>public</code> modifier to both, resulting in a conflict.","children":[{"content":"<strong>Differences between Interfaces and Abstract Classes</strong><br>\nEven though abstract classes and interfaces are both considered abstract types,<br>\nonly <strong>interfaces make use of implicit modifiers.</strong> How do the <code>play()</code> methods<br>\ndiffer in the following two definitions?<pre data-lines=\"216,224\"><code class=\"language-java\"><span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Husky</span> {  <span class=\"hljs-comment\">// abstract modifier required</span>\n  <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">play</span><span class=\"hljs-params\">()</span>; <span class=\"hljs-comment\">// abstract modifier required</span>\n}\n<span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">Poodle</span> {      <span class=\"hljs-comment\">// abstract modifier optional</span>\n  <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">play</span><span class=\"hljs-params\">()</span>;          <span class=\"hljs-comment\">// abstract modifier optional</span>\n}\n</code></pre>","children":[{"content":"Both of these method definitions are considered abstract. That said, the <code>Husky</code> class will<br>\nnot compile if the <code>play()</code> method is not marked <code>abstract</code>, whereas the method in the<br>\n<code>Poodle</code> interface will compile with or without the <code>abstract</code> modifier.","children":[{"content":"What about the access level of the <code>play()</code> method?<pre data-lines=\"228,236\"><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Webby</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">Husky</span> {\n  <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">play</span><span class=\"hljs-params\">()</span> {} <span class=\"hljs-comment\">// play() is declared with package access in Husky</span>\n}\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Georgette</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">Poodle</span> {\n  <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">play</span><span class=\"hljs-params\">()</span> {} <span class=\"hljs-comment\">// DOES NOT COMPILE - play() is public in Poodle</span>\n}\n</code></pre>\nThe <code>Webby</code> class compiles, but the <code>Georgette</code> class does not. Even though the<br>\ntwo method implementations are identical, the method in the <code>Georgette</code> class<br>\nreduces the access modifier on the method from <code>public</code> to package access.","children":[],"payload":{"tag":"li","lines":"227,239"}}],"payload":{"tag":"li","lines":"224,239"}}],"payload":{"tag":"li","lines":"212,239"}}],"payload":{"tag":"li","lines":"201,239"}}],"payload":{"tag":"li","lines":"185,239"}}],"payload":{"tag":"li","lines":"181,239"}}],"payload":{"tag":"li","lines":"175,239"}}],"payload":{"tag":"li","lines":"170,239"}},{"content":"<strong>Declaring Concrete Interface Methods</strong><br>\nIn <strong>Table 7.1</strong>, the membership type determines how it is able to be accessed. A method<br>\nwith a membership type of class is shared among all instances of the interface, whereas<br>\na method with a membership type of instance is associated with a particular instance of<br>\nthe interface.","children":[{"content":"<strong>TABLE 7.1</strong> Interface member types\n<table data-lines=\"245,253\">\n<thead data-lines=\"245,246\">\n<tr data-lines=\"245,246\">\n<th></th>\n<th>Membership<br>type</th>\n<th>Required<br>modifiers</th>\n<th>Implicit modifiers</th>\n<th>Has value or body?</th>\n</tr>\n</thead>\n<tbody data-lines=\"247,253\">\n<tr data-lines=\"247,248\">\n<td>Constant variable</td>\n<td>Class</td>\n<td>-</td>\n<td><code>public</code>, <code>static</code>, <code>final</code></td>\n<td>Yes</td>\n</tr>\n<tr data-lines=\"248,249\">\n<td><code>abstract</code> method</td>\n<td>Instance</td>\n<td>-</td>\n<td><code>public</code>, <code>abstract</code></td>\n<td>No</td>\n</tr>\n<tr data-lines=\"249,250\">\n<td><code>default</code> method</td>\n<td>Instance</td>\n<td><code>default</code></td>\n<td><code>public</code></td>\n<td>Yes</td>\n</tr>\n<tr data-lines=\"250,251\">\n<td><code>static</code> method</td>\n<td>Class</td>\n<td><code>static</code></td>\n<td><code>public</code></td>\n<td>Yes</td>\n</tr>\n<tr data-lines=\"251,252\">\n<td><code>private</code> method</td>\n<td>Instance</td>\n<td><code>private</code></td>\n<td>-</td>\n<td>Yes</td>\n</tr>\n<tr data-lines=\"252,253\">\n<td><code>private static</code> method</td>\n<td>Class</td>\n<td><code>private static</code></td>\n<td>-</td>\n<td>Yes</td>\n</tr>\n</tbody>\n</table>","children":[{"content":"<strong>What About protected or Package Interface Members?</strong><br>\nInterfaces do not support protected members. They also do<br>\nnot support package access members.","children":[{"content":"<strong>Writing a default Interface Method</strong><br>\nA default method is a method defined in an interface with the <code>default</code> keyword and includes<br>\na method body. It may be optionally overridden by a class implementing the interface.<br>\nOne use of <code>default</code> methods is for backward compatibility. You can add a new <code>default</code><br>\nmethod to an interface without the need to modify all of the existing classes that implement<br>\nthe interface. The older classes will just use the default implementation of the method defined<br>\nin the interface.","children":[{"content":"The following is an example of a default method defined in an interface:<pre data-lines=\"264,272\"><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">IsColdBlooded</span> {\n  <span class=\"hljs-type\">boolean</span> <span class=\"hljs-title function_\">hasScales</span><span class=\"hljs-params\">()</span>;\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-type\">double</span> <span class=\"hljs-title function_\">getTemperature</span><span class=\"hljs-params\">()</span>{<span class=\"hljs-comment\">//public is optional</span>\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">10.0</span>;\n  }\n}\n</code></pre>","children":[{"content":"This example defines two interface methods, one <code>abstract</code> and one <code>default</code>. The following<br>\n<code>Snake</code> class, which implements <code>IsColdBlooded</code>, must implement <code>hasScales()</code>. It may<br>\nrely on the default implementation of <code>getTemperature()</code> or override the method with its<br>\nown version:<pre data-lines=\"276,285\"><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Snake</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">IsColdBlooded</span> {\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">boolean</span> <span class=\"hljs-title function_\">hasScales</span><span class=\"hljs-params\">()</span> { <span class=\"hljs-comment\">// Required override</span>\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\n  }\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">double</span> <span class=\"hljs-title function_\">getTemperature</span><span class=\"hljs-params\">()</span> { <span class=\"hljs-comment\">// Optional override</span>\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">12.2</span>;\n  } }\n</code></pre>","children":[{"content":"<strong>Default Interface Method Definition Rules</strong><br>\n1.- A <code>default</code> method may be declared only within an interface.<br>\n2.- A <code>default</code> method must be marked with the <code>default</code> keyword and include a method body.<br>\n3.- A <code>default</code> method is implicitly <code>public</code>.<br>\n4.- A <code>default</code> method cannot be marked <code>abstract</code>, <code>final</code>, or <code>static</code>.<br>\n5.- A <code>default</code> method may be overridden by a class that implements the interface.<br>\n6.- If a class inherits two or more <code>default</code> methods with the same method signature,<br>\n&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;then the class must override the method.","children":[{"content":"The first rule should give you some comfort in that you&#x2019;ll only see <code>default</code> methods<br>\nin interfaces. If you see them in a class or enum on the exam, something is wrong.<br>\nThe second rule just denotes syntax, as <code>default</code> methods must use the <code>default</code><br>\nkeyword. For example, the following code snippets will not compile because they<br>\nmix up concrete and abstract interface methods:<pre data-lines=\"298,305\"><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">Carnivore</span> {\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">eatMeat</span><span class=\"hljs-params\">()</span>; <span class=\"hljs-comment\">// DOES NOT COMPILE</span>\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">getRequiredFoodAmount</span><span class=\"hljs-params\">()</span> { <span class=\"hljs-comment\">// DOES NOT COMPILE</span>\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">13</span>;\n  } }\n</code></pre>","children":[],"payload":{"tag":"li","lines":"293,305"}}],"payload":{"tag":"li","lines":"285,305"}}],"payload":{"tag":"li","lines":"272,305"}}],"payload":{"tag":"li","lines":"263,305"}}],"payload":{"tag":"li","lines":"256,305"}}],"payload":{"tag":"li","lines":"253,305"}}],"payload":{"tag":"li","lines":"244,305"}}],"payload":{"tag":"li","lines":"239,305"}},{"content":"The next three rules for <code>default</code> methods follow from the relationship with abstract<br>\ninterface methods. Like abstract interface methods, <code>default</code> methods are implicitly<br>\n<code>public</code>. Unlike abstract methods, though, <code>default</code> interface methods cannot be<br>\nmarked <code>abstract</code> since they provide a body. They also cannot be marked as <code>final</code>,<br>\nbecause they are designed so that they can be overridden in classes implementing<br>\nthe interface, just like abstract methods. Finally, they cannot be marked <code>static</code> since<br>\nthey are associated with the instance of the class implementing the interface.","children":[{"content":"<strong>Inheriting Duplicate <em><code>default</code></em> Methods</strong><br>\nThe last rule for creating a default interface method requires some explanation.<pre data-lines=\"314,323\"><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">Walk</span> {\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">getSpeed</span><span class=\"hljs-params\">()</span> { <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">5</span>; }\n}\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">Run</span> {\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">getSpeed</span><span class=\"hljs-params\">()</span> { <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">10</span>; }\n}\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Cat</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">Walk</span>, Run {} <span class=\"hljs-comment\">// DOES NOT COMPILE</span>\n</code></pre>","children":[{"content":"In this example, <code>Cat</code> inherits the two default methods for <code>getSpeed()</code>, so which does it use?<br>\nSince <code>Walk</code> and <code>Run</code> are considered siblings in terms of how they are used in the <code>Cat</code><br>\nclass, it is not clear whether the code should output <code>5</code> or <code>10</code>; then the <code>Cat</code> does not compile.<br>\n<strong style=\"color:green\">If one of the two interfaces was a class, then the class implementation wins.</strong><br>\nIf the class implementing the interfaces overrides the duplicate default method, the code will<br>\ncompile without issue. By overriding the conflicting method, the ambiguity about which version<br>\nof the method to call has been removed. For example, the following modified implementation<br>\nof  <code>Cat</code> will compile:<pre data-lines=\"331,336\"><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Cat</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">Walk</span>, Run {\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">getSpeed</span><span class=\"hljs-params\">()</span> { <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>; }\n}\n</code></pre>","children":[{"content":"<strong>Calling a <em><code>default</code></em> Method</strong><br>\nA <code>default</code> method exists on any object inheriting the interface, not on the interface itself. In other<br>\nwords, you should treat it like an inherited method that can be optionally overridden, rather than<br>\nas a <code>static</code> method. Consider the following:<pre data-lines=\"340,351\"><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">Dance</span> {\n  <span class=\"hljs-keyword\">default</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">getRhythm</span><span class=\"hljs-params\">()</span> { <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">33</span>; }\n}\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Snake</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">Dance</span> {\n  <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">move</span><span class=\"hljs-params\">()</span> {\n    <span class=\"hljs-type\">var</span> <span class=\"hljs-variable\">snake</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Snake</span>();\n    System.out.print(snake.getRhythm());\n    System.out.print(Dance.getRhythm()); <span class=\"hljs-comment\">// DOES NOT COMPILE</span>\n  } }\n</code></pre>","children":[{"content":"The first call to <code>getRhythm()</code> compiles because it is called on an instance of the <code>Snake</code> class.<br>\nThe second does not compile because it is not a <code>static</code> method and requires an instance<br>\nof <code>Dance</code>.<br>\nIn the previous section, we showed how our <code>Cat</code> class could override a pair of conflicting <code>default</code><br>\nmethods, but what if the <code>Cat</code> class wanted to access the &#x201c;hidden&#x201d; version of <code>getSpeed()</code> in <code>Walk</code><br>\nor <code>Run</code>? Is it still accessible? Yes, but it requires some special syntax.<pre data-lines=\"357,366\"><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Cat</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">Walk</span>, Run {\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">getSpeed</span><span class=\"hljs-params\">()</span> {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;\n  }\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">getWalkSpeed</span><span class=\"hljs-params\">()</span> {\n    <span class=\"hljs-keyword\">return</span> Walk.<span class=\"hljs-built_in\">super</span>.getSpeed();\n  } }\n</code></pre>","children":[{"content":"This is an area where a <code>default</code> method <code>getSpeed()</code> exhibits properties of both an<br>\ninstance and <code>static</code> method. We use the interface name to indicate which method<br>\nwe want to call, but we use the <code>super</code> keyword to show that we are following<br>\ninstance inheritance, not class inheritance.","children":[{"content":"<strong>Declaring static Interface Methods</strong><br>\nInterfaces can also include <code>static</code> methods. These methods<br>\nare defined explicitly with the <code>static</code> keyword and, for the<br>\nmost part, behave just like <code>static</code> methods defined in classes.","children":[{"content":"<strong>Static Interface Method Definition Rules</strong><br>\n1.- A <code>static</code> method must be marked with the <code>static</code> keyword and include a method body.<br>\n2.- A <code>static</code> method without an access modifier is implicitly <code>public</code>.<br>\n3.- A <code>static</code> method cannot be marked <code>abstract</code> or <code>final</code>.<br>\n4.- A <code>static</code> method is not inherited and cannot be accessed in a class implementing the<br>\n&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;interface without a reference to the interface name.","children":[],"payload":{"tag":"li","lines":"374,380"}}],"payload":{"tag":"li","lines":"370,380"}}],"payload":{"tag":"li","lines":"366,380"}}],"payload":{"tag":"li","lines":"351,380"}}],"payload":{"tag":"li","lines":"336,380"}}],"payload":{"tag":"li","lines":"323,380"}}],"payload":{"tag":"li","lines":"312,380"}}],"payload":{"tag":"li","lines":"305,380"}},{"content":"These rules should follow from what you know so far of classes, interfaces, and <code>static</code><br>\nmethods. For example, you can&#x2019;t declare <code>static</code> methods without a body in classes,<br>\neither. Like <code>default</code> and <code>abstract</code> interface methods, <code>static</code> interface methods are<br>\nimplicitly <code>public</code> if they are declared without an access modifier. As you see shortly,<br>\nyou can use the <code>private</code> access modifier with <code>static</code> methods.<br>\nLet&#x2019;s take a look at a <code>static</code> interface method:<pre data-lines=\"386,392\"><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">Hop</span> {\n  <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">getJumpHeight</span><span class=\"hljs-params\">()</span> {<span class=\"hljs-comment\">//implicit public</span>\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">8</span>;\n  } }\n</code></pre>","children":[{"content":"Since the method is defined without an access modifier, the compiler will automatically<br>\ninsert the <code>public</code> access modifier. The method <code>getJumpHeight()</code> works just like a <code>static</code><br>\nmethod as defined in a class. In other words, it can be accessed without an instance of<br>\na class.<pre data-lines=\"396,402\"><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Skip</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">Hop</span> {\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">skip</span><span class=\"hljs-params\">()</span> {\n    <span class=\"hljs-keyword\">return</span> Hop.getJumpHeight();\n  } }\n</code></pre>","children":[{"content":"The last rule about inheritance might be a little confusing, so let&#x2019;s look at an example. The<br>\nfollowing is an example of a class <code>Bunny</code> that implements <code>Hop</code> and does not compile:<pre data-lines=\"404,410\"><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Bunny</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">Hop</span> {\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">printDetails</span><span class=\"hljs-params\">()</span> {\n    System.out.println(getJumpHeight()); <span class=\"hljs-comment\">// DOES NOT COMPILE</span>\n  } }\n</code></pre>\nWithout an explicit reference to the name of the interface, the code will not compile, even<br>\nthough <code>Bunny</code> implements <code>Hop</code>. This can be easily fixed by using the interface name:<pre data-lines=\"412,415\"><code class=\"language-java\">    System.out.println(Hop.getJumpHeight());\n</code></pre>","children":[{"content":"Notice we don&#x2019;t have the same problem we did when we inherited two <code>default</code> interface<br>\nmethods with the same signature. Java &#x201c;solved&#x201d; the multiple inheritance problem of<br>\n<code>static</code> interface methods by not allowing them to be inherited!","children":[{"content":"<strong>Reusing Code with private Interface Methods</strong><br>\nThe last two types of methods that can be added to interfaces are <code>private</code> (concrete) and<br>\n<code>private static</code> interface methods. Because both types of methods are <code>private</code>, they can<br>\nonly be used in the interface declaration in which they are declared. For this reason, they<br>\nwere added primarily to reduce code duplication. For example, consider the following code<br>\nsample:","children":[{"content":"\n<pre data-lines=\"424,439\"><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">Schedule</span> {\n  <span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">wakeUp</span><span class=\"hljs-params\">()</span> { checkTime(<span class=\"hljs-number\">7</span>); }\n  <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">haveBreakfast</span><span class=\"hljs-params\">()</span> { checkTime(<span class=\"hljs-number\">9</span>); }\n  <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">workOut</span><span class=\"hljs-params\">()</span> { checkTime(<span class=\"hljs-number\">18</span>); }\n  <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">checkTime</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> hour)</span> {\n    <span class=\"hljs-keyword\">if</span> (hour &gt; <span class=\"hljs-number\">17</span>) {\n      System.out.println(<span class=\"hljs-string\">&quot;You&#x2019;re late!&quot;</span>);\n    } <span class=\"hljs-keyword\">else</span> {\n      System.out.println(<span class=\"hljs-string\">&quot;You have &quot;</span>+(<span class=\"hljs-number\">17</span>-hour)+<span class=\"hljs-string\">&quot; hours left &quot;</span>\n            + <span class=\"hljs-string\">&quot;to make the appointment&quot;</span>);\n    }\n  }\n}\n</code></pre>","children":[{"content":"You could write this interface without using a <code>private</code> method by copying the contents of the<br>\n<code>checkTime()</code> method into the places it is used. It&#x2019;s a lot shorter and easier to read if you don&#x2019;t!<br>\nSince the authors of Java were nice enough to add this feature for our convenience, we might<br>\nas well use it!<br>\nThe difference between a non-<code>static private</code> method and a <code>static</code> one is analogous to the<br>\ndifference between an instance and <code>static</code> method declared within a class.","children":[{"content":"<strong>Private Interface Method Definition Rules</strong><br>\n1.- A <code>private</code> interface method must be marked with the <code>private</code> modifier and include a method body.<br>\n2.- A <code>private static</code> interface method may be called by any method within the interface definition.<br>\n3.- A <code>private</code> interface method may only be called by default and other <code>private</code> non-<code>static</code> methods<br>\nwithin the interface definition.","children":[],"payload":{"tag":"li","lines":"445,450"}},{"content":"Another way to think of it is that a <code>private</code> interface method is only accessible to non-<code>static</code> methods<br>\ndefined within the interface. A <code>private static</code> interface method, on the other hand, can be accessed<br>\nby any method in the interface. For both types of <code>private</code> methods, a class inheriting the interface<br>\ncannot directly invoke them.","children":[],"payload":{"tag":"li","lines":"450,454"}}],"payload":{"tag":"li","lines":"439,454"}}],"payload":{"tag":"li","lines":"424,454"}}],"payload":{"tag":"li","lines":"418,454"}}],"payload":{"tag":"li","lines":"415,454"}}],"payload":{"tag":"li","lines":"402,454"}}],"payload":{"tag":"li","lines":"392,454"}}],"payload":{"tag":"li","lines":"380,454"}},{"content":"<strong>Reviewing Interface Members</strong><br>\nWe conclude our discussion of interface members with<br>\nTable 7.2, which shows the access rules for members<br>\nwithin and outside an interface.","children":[{"content":"<strong>TABLE 7.2</strong> Interface member access\n<table data-lines=\"459,467\">\n<thead data-lines=\"459,460\">\n<tr data-lines=\"459,460\">\n<th></th>\n<th>Accessible <br>from <code>default</code><br> and <code>private</code> <br> methods <br>within  the<br> interface?</th>\n<th>Accessible<br> from <code>static</code><br> methods<br> within the <br>interface?</th>\n<th>Accessible<br> from methods <br>in classes<br> inheriting <br>the interface?</th>\n<th>Accessible<br> without an <br>instance of<br> the interface?</th>\n</tr>\n</thead>\n<tbody data-lines=\"461,467\">\n<tr data-lines=\"461,462\">\n<td>Constant variable</td>\n<td>Yes</td>\n<td>Yes</td>\n<td>Yes</td>\n<td>Yes</td>\n</tr>\n<tr data-lines=\"462,463\">\n<td><code>abstract</code> method</td>\n<td>Yes</td>\n<td>No</td>\n<td>Yes</td>\n<td>No</td>\n</tr>\n<tr data-lines=\"463,464\">\n<td><code>default</code> method</td>\n<td>Yes</td>\n<td>No</td>\n<td>Yes</td>\n<td>No</td>\n</tr>\n<tr data-lines=\"464,465\">\n<td><code>static</code> method</td>\n<td>Yes</td>\n<td>Yes</td>\n<td>Yes (interface<br> name required)</td>\n<td>Yes (interface<br> name required)</td>\n</tr>\n<tr data-lines=\"465,466\">\n<td><code>private</code> method</td>\n<td>Yes</td>\n<td>No</td>\n<td>No</td>\n<td>No</td>\n</tr>\n<tr data-lines=\"466,467\">\n<td><code>private static</code> method</td>\n<td>Yes</td>\n<td>Yes</td>\n<td>No</td>\n<td>No</td>\n</tr>\n</tbody>\n</table>","children":[{"content":"While <strong>Table 7.2</strong> might seem like a lot to remember, here are some quick tips for the exam:<br>\n* Treat <code>abstract</code>, <code>default</code>, and non-<code>static private</code> methods as belonging to an instance of the interface.<br>\n* Treat <code>static</code> methods and variables as belonging to the interface class object.<br>\n* All <code>private</code> interface method types are only accessible within the interface declaration.","children":[{"content":"Using these rules, which of the following methods do not compile?<pre data-lines=\"472,481\"><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">ZooTrainTour</span> {\n  <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">getTrainName</span><span class=\"hljs-params\">()</span>;\n  <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">ride</span><span class=\"hljs-params\">()</span> {}\n  <span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">playHorn</span><span class=\"hljs-params\">()</span> { getTrainName(); ride(); }\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">slowDown</span><span class=\"hljs-params\">()</span> { playHorn(); }\n  <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">speedUp</span><span class=\"hljs-params\">()</span> { ride(); }\n}\n</code></pre>","children":[{"content":"The <code>ride()</code> method is <code>private</code> and <code>static</code>, so it can be accessed by any <code>default</code> or <code>static</code><br>\nmethod within the interface declaration. The <code>getTrainName()</code> is <code>abstract</code>, so it can be<br>\naccessed by a <code>default</code> method associated with the instance. The <code>slowDown()</code> method<br>\nis <code>static</code>, though, and cannot call a <code>default</code> or <code>private</code> method, such as <code>playHorn()</code>,<br>\nwithout an explicit reference object. Therefore, the <code>slowDown()</code> method does not compile.","children":[],"payload":{"tag":"li","lines":"481,486"}}],"payload":{"tag":"li","lines":"471,486"}}],"payload":{"tag":"li","lines":"467,486"}}],"payload":{"tag":"li","lines":"458,486"}}],"payload":{"tag":"li","lines":"454,486"}}],"payload":{"tag":"h1","lines":"6,7"}},{"initialExpandLevel":1})</script>
</body>
</html>
