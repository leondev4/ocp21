<!doctype html>
<html>
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta http-equiv="X-UA-Compatible" content="ie=edge" />
<title>Markmap</title>
<style>
* {
  margin: 0;
  padding: 0;
}
html {
  font-family: ui-sans-serif, system-ui, sans-serif, 'Apple Color Emoji',
    'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji';
}
#mindmap {
  display: block;
  width: 100vw;
  height: 100vh;
}
.markmap-dark {
  background: #27272a;
  color: white;
}
</style>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/markmap-toolbar@0.18.12/dist/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@highlightjs/cdn-assets@11.11.1/styles/default.min.css">
</head>
<body>
<svg id="mindmap"></svg>
<script src="https://cdn.jsdelivr.net/npm/d3@7.9.0/dist/d3.min.js"></script><script src="https://cdn.jsdelivr.net/npm/markmap-view@0.18.12/dist/browser/index.js"></script><script src="https://cdn.jsdelivr.net/npm/markmap-toolbar@0.18.12/dist/index.js"></script><script>(r => {
              setTimeout(r);
            })(function renderToolbar() {
  const {
    markmap,
    mm
  } = window;
  const {
    el
  } = markmap.Toolbar.create(mm);
  el.setAttribute('style', 'position:absolute;bottom:20px;right:20px');
  document.body.append(el);
})</script><script>((getMarkmap, getOptions, root2, jsonOptions) => {
              const markmap = getMarkmap();
              window.mm = markmap.Markmap.create(
                "svg#mindmap",
                (getOptions || markmap.deriveOptions)(jsonOptions),
                root2
              );
              if (window.matchMedia("(prefers-color-scheme: dark)").matches) {
                document.documentElement.classList.add("markmap-dark");
              }
            })(() => window.markmap,null,{"content":"<strong>Working with Records</strong>","children":[{"content":"A record is a special type of data-oriented class in which the compiler inserts boilerplate<br>\ncode for you. (See <a href=\"https://1drv.ms/i/c/c83cfca51d5c2032/EYB95hSHoHVMoRWRKHWJ2IQBuLCNyHySnqc9EFVRqU48zw?e=JfNXzi\">Figure 7.6</a>).<br>\nThe compiler inserts useful implementations of the <code>Object</code> methods <code>equals()</code>, <code>hashCode()</code>,<br>\nand <code>toString()</code>.","children":[{"content":"A <code>record</code> implicitly extends <code>java.lang.Record</code> class but it is not allowed to have an<br>\n<code>extends</code> clause. A <code>record</code> is implicitly <code>final</code>.<br>\nIf we have an application with hundreds of POJOs, a <code>record</code> can save us valuable<br>\ntime.","children":[{"content":"Creating an instance of a <code>Crane</code> and printing some fields is easy:<pre data-lines=\"15,20\"><code class=\"language-java\"><span class=\"hljs-type\">var</span> <span class=\"hljs-variable\">mommy</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Crane</span>(<span class=\"hljs-number\">4</span>, <span class=\"hljs-string\">&quot;Cammy&quot;</span>);\nSystem.out.println(mommy.numberEggs()); <span class=\"hljs-comment\">// 4</span>\nSystem.out.println(mommy.name()); <span class=\"hljs-comment\">// Cammy</span>\n</code></pre>\nA few things should stand out here. First, we never defined any constructors<br>\nor methods in our <code>Crane</code> declaration. How does the compiler know what to<br>\ndo? Behind the scenes, it creates a constructor for you with the parameters<br>\nin the same order in which they appear in the record declaration.","children":[{"content":"Omitting or changing the type order will lead to compiler errors:<pre data-lines=\"25,29\"><code class=\"language-java\"><span class=\"hljs-type\">var</span> <span class=\"hljs-variable\">mommy1</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Crane</span>(<span class=\"hljs-string\">&quot;Cammy&quot;</span>, <span class=\"hljs-number\">4</span>); <span class=\"hljs-comment\">// DOES NOT COMPILE</span>\n<span class=\"hljs-type\">var</span> <span class=\"hljs-variable\">mommy2</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Crane</span>(<span class=\"hljs-string\">&quot;Cammy&quot;</span>);    <span class=\"hljs-comment\">// DOES NOT COMPILE</span>\n</code></pre>\nFor each field, it also creates an accessor as the field name, plus a<br>\nset of parentheses. Finally, records override a number of methods in<br>\n<code>Object</code> for you.","children":[{"content":"<strong>Members Automatically Added to Records</strong><br>\n<strong>Constructor:</strong> A constructor with the parameters in the same order as the record declaration<br>\n<strong>Accessor method:</strong> One accessor for each field<br>\n<strong><code>equals()</code>:</strong> A method to compare two elements that returns true if each field is equal in terms of <code>equals()</code><br>\n<strong><code>hashCode()</code>:</strong> A consistent <code>hashCode()</code> method using all of the fields<br>\n<strong><code>toString()</code>:</strong> A <code>toString()</code> implementation that prints each field of the record in a convenient, easy-to-read format","children":[{"content":"\n<pre data-lines=\"38,47\"><code class=\"language-java\"><span class=\"hljs-type\">var</span> <span class=\"hljs-variable\">father</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Crane</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-string\">&quot;Craig&quot;</span>);\nSystem.out.println(father); <span class=\"hljs-comment\">//Crane[numberEggs=0, name=Craig]</span>\n\n<span class=\"hljs-type\">var</span> <span class=\"hljs-variable\">copy</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Crane</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-string\">&quot;Craig&quot;</span>);\nSystem.out.println(copy); <span class=\"hljs-comment\">//Crane[numberEggs=0, name=Craig]</span>\nSystem.out.println(father.equals(copy)); <span class=\"hljs-comment\">// true</span>\nSystem.out.println(father.hashCode() + <span class=\"hljs-string\">&quot;, &quot;</span> + copy.hashCode()); <span class=\"hljs-comment\">// 1007, 1007</span>\n</code></pre>","children":[{"content":"It is legal to have a record without any fields. It is simply declared with the <code>record</code><br>\nkeyword and parentheses:<pre data-lines=\"49,52\"><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">record</span> <span class=\"hljs-title class_\">Crane</span><span class=\"hljs-params\">()</span> {}\n</code></pre>\nThis is not the kind of thing you&#x2019;d use in your own code, but it could come up on<br>\nthe exam.","children":[],"payload":{"tag":"li","lines":"47,54"}}],"payload":{"tag":"li","lines":"38,54"}}],"payload":{"tag":"li","lines":"32,54"}}],"payload":{"tag":"li","lines":"24,54"}}],"payload":{"tag":"li","lines":"14,54"}}],"payload":{"tag":"li","lines":"10,54"}}],"payload":{"tag":"li","lines":"6,54"}},{"content":"<strong>Declaring Constructors</strong><br>\nWe have two ways to create constructors in records.","children":[{"content":"<strong>The Long Constructor</strong><br>\nFirst, we can just declare the constructor the compiler normally inserts automatically, which we refer to as<br>\nthe long constructor (same types and names of parameters).<pre data-lines=\"59,68\"><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">record</span> <span class=\"hljs-title class_\">Crane</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> numberEggs, String name)</span> {\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">Crane</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> numberEggs, String name)</span> {\n    <span class=\"hljs-keyword\">if</span> (numberEggs &lt; <span class=\"hljs-number\">0</span>) <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">IllegalArgumentException</span>();\n    <span class=\"hljs-built_in\">this</span>.numberEggs = numberEggs;\n    <span class=\"hljs-built_in\">this</span>.name = name; <span class=\"hljs-comment\">//you can use this keyword</span>\n  }\n}\n</code></pre>","children":[{"content":"The compiler will not insert a constructor if you define one with the same list of parameters in the same order.<br>\nSince each field is <code>final</code>, the constructor must set every field. For example, this record does not compile:<pre data-lines=\"70,75\"><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">record</span> <span class=\"hljs-title class_\">Crane</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> numberEggs, String name)</span> {\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">Crane</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> numberEggs, String name)</span> {} <span class=\"hljs-comment\">// DOES NOT COMPILE</span>\n}\n</code></pre>","children":[{"content":"<strong>Compact Constructors</strong><br>\nLuckily, the authors of Java added the ability to define a compact constructor for records. A compact constructor<br>\nis a special type of constructor used for records to process validation and transformations succinctly. It takes no<br>\nparameters and <strong>implicitly sets all fields</strong>. <a href=\"https://1drv.ms/i/c/c83cfca51d5c2032/EXh6DXIoHmZAmtQ31Cz3v1IBTuJidRaB7ocZaqyZWHJmaw?e=9MPQsG\">Figure 7.7</a> shows an example of a compact constructor. <strong>You cannot<br>\nuse <code>this</code> keyword inside it.</strong>","children":[{"content":"Great! Now we can check the values we want, and we don&#x2019;t have to list all the constructor parameters and trivial<br>\nassignments. <strong>Java will execute the full constructor after the compact constructor.</strong> You should also remember<br>\nthat a <strong>compact constructor is declared without parentheses</strong>, as the exam might try to trick you on this. As<br>\nshown in Figure 7.7, we can even transform constructor parameters.","children":[{"content":"<strong>Transforming Parameters</strong><br>\nCompact constructors give you the opportunity to apply transformations to any of the input values. See if you can<br>\nfigure out what the following compact constructor does:<pre data-lines=\"87,96\"><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">record</span> <span class=\"hljs-title class_\">Crane</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> numberEggs, String name)</span> {\n  <span class=\"hljs-keyword\">public</span> Crane {\n    <span class=\"hljs-keyword\">if</span> (name == <span class=\"hljs-literal\">null</span> || name.length() &lt; <span class=\"hljs-number\">1</span>)\n      <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">IllegalArgumentException</span>();\n    name = name.substring(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>).toUpperCase() + name.substring(<span class=\"hljs-number\">1</span>).toLowerCase();\n  }\n}\n</code></pre>","children":[{"content":"It validates the string, then formats it such that only the first letter is capitalized. As before, <strong>Java calls the<br>\nfull constructor after the compact constructor but with the modified constructor parameters.</strong>","children":[{"content":"While compact constructors can modify the constructor parameters, they cannot modify the fields  of the<br>\nrecord. For example, this does not compile:<pre data-lines=\"100,107\"><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">record</span> <span class=\"hljs-title class_\">Crane</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> numberEggs, String name)</span> {\n  <span class=\"hljs-keyword\">public</span> Crane {\n    <span class=\"hljs-built_in\">this</span>.numberEggs = <span class=\"hljs-number\">10</span>; <span class=\"hljs-comment\">// DOES NOT COMPILE</span>\n  }\n}\n</code></pre>\nRemoving the <code>this</code> reference allows the code to compile, as the constructor parameter is modified instead.","children":[],"payload":{"tag":"li","lines":"98,108"}}],"payload":{"tag":"li","lines":"96,108"}}],"payload":{"tag":"li","lines":"84,108"}}],"payload":{"tag":"li","lines":"80,108"}}],"payload":{"tag":"li","lines":"75,108"}}],"payload":{"tag":"li","lines":"68,108"}}],"payload":{"tag":"li","lines":"56,108"}}],"payload":{"tag":"li","lines":"54,108"}},{"content":"<strong>Overloaded Constructors</strong><br>\nYou can also create overloaded constructors that take a completely different list of<br>\nparameters. They are more closely related to the long-form constructor and don&#x2019;t<br>\nuse any of the syntactical features of compact constructors.<pre data-lines=\"112,119\"><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">record</span> <span class=\"hljs-title class_\">Crane</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> numberEggs, String name)</span> {\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">Crane</span><span class=\"hljs-params\">(String firstName, String lastName)</span> {\n    <span class=\"hljs-built_in\">this</span>(<span class=\"hljs-number\">0</span>, firstName + <span class=\"hljs-string\">&quot; &quot;</span> + lastName); <span class=\"hljs-comment\">//must be the first call</span>\n  }\n}\n</code></pre>","children":[{"content":"The first line of an overloaded constructor must be an explicit call to another constructor via <code>this()</code>.<br>\nIf there are no other constructors, the long constructor must be called. Also, unlike compact<br>\nconstructors, you can only transform the data on the first line. <strong>After the first line, all of the fields<br>\nwill already be assigned, and the object is immutable.</strong><pre data-lines=\"123,132\"><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">record</span> <span class=\"hljs-title class_\">Crane</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> numberEggs, String name)</span> {\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">Crane</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> numberEggs, String firstName, String lastName)</span> {\n    <span class=\"hljs-built_in\">this</span>(numberEggs + <span class=\"hljs-number\">1</span>, firstName + <span class=\"hljs-string\">&quot; &quot;</span> + lastName);\n    numberEggs = <span class=\"hljs-number\">10</span>; <span class=\"hljs-comment\">// NO EFFECT (applies to parameter, not instance field)</span>\n    <span class=\"hljs-built_in\">this</span>.numberEggs = <span class=\"hljs-number\">20</span>; <span class=\"hljs-comment\">// DOES NOT COMPILE (final field)</span>\n  }\n}\n</code></pre>","children":[{"content":"<strong>Only the long constructor, with fields that match the record declaration, supports setting<br>\nfield values with a <code>this</code> reference. Compact and overloaded constructors do not.</strong>","children":[{"content":"You also can&#x2019;t declare two record constructors that call each other infinitely or as a cycle.<pre data-lines=\"135,145\"><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">record</span> <span class=\"hljs-title class_\">Crane</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> numberEggs, String name)</span> {\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">Crane</span><span class=\"hljs-params\">(String name)</span> {\n    <span class=\"hljs-built_in\">this</span>(<span class=\"hljs-number\">1</span>); <span class=\"hljs-comment\">// DOES NOT COMPILE</span>\n  }\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">Crane</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> numberEggs)</span> {\n    <span class=\"hljs-built_in\">this</span>(<span class=\"hljs-string\">&quot;&quot;</span>); <span class=\"hljs-comment\">// DOES NOT COMPILE</span>\n  }\n}\n</code></pre>","children":[{"content":"<strong>Understanding Record Immutability</strong><br>\nAs you saw, records don&#x2019;t have setters. Every field is inherently <code>final</code> and cannot be modified<br>\nafter it has been written in the constructor. To &#x201c;modify&#x201d; a record, you have to make a new<br>\nobject and copy all of the data you want to preserve.<pre data-lines=\"149,153\"><code class=\"language-java\"><span class=\"hljs-type\">var</span> <span class=\"hljs-variable\">cousin</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Crane</span>(<span class=\"hljs-number\">3</span>, <span class=\"hljs-string\">&quot;Jenny&quot;</span>);\n<span class=\"hljs-type\">var</span> <span class=\"hljs-variable\">friend</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Crane</span>(cousin.numberEggs(), <span class=\"hljs-string\">&quot;Janeice&quot;</span>);\n</code></pre>","children":[{"content":"Just as interfaces are implicitly <code>abstract</code>, <strong>records are also implicitly <code>final</code>.</strong> The <code>final</code><br>\nmodifier is optional but assumed.<pre data-lines=\"155,158\"><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">record</span> <span class=\"hljs-title class_\">Crane</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> numberEggs, String name)</span> {}\n</code></pre>\n<strong>Like enums, that means you can&#x2019;t extend or inherit a record.</strong><pre data-lines=\"159,162\"><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">record</span> <span class=\"hljs-title class_\">BlueCrane</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">Crane</span> {} <span class=\"hljs-comment\">// DOES NOT COMPILE</span>\n</code></pre>","children":[{"content":"<strong>Also like enums, a record can implement a regular or sealed interface</strong>, provided<br>\nit implements all of the abstract methods.<pre data-lines=\"164,168\"><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">Bird</span> {}\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">record</span> <span class=\"hljs-title class_\">Crane</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> numberEggs, String name)</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">Bird</span> {}\n</code></pre>","children":[{"content":"While instance members of a record are <code>final</code> (they can be declared only in the<br>\ndefinition of record), the <code>static</code> members are not required to be. For example,<br>\nthe following defines an immutable record in which a <code>static</code> value is updated<br>\nevery time a record is created.<pre data-lines=\"172,180\"><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">record</span> <span class=\"hljs-title class_\">WhoopingCrane</span><span class=\"hljs-params\">(String name, <span class=\"hljs-type\">int</span> position)</span> {\n  <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">counter</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>;\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">WhoopingCrane</span><span class=\"hljs-params\">(String name)</span> {\n    <span class=\"hljs-built_in\">this</span>(name, counter++);\n  }\n}\n</code></pre>","children":[],"payload":{"tag":"li","lines":"168,180"}}],"payload":{"tag":"li","lines":"162,180"}}],"payload":{"tag":"li","lines":"153,180"}}],"payload":{"tag":"li","lines":"145,180"}}],"payload":{"tag":"li","lines":"134,180"}}],"payload":{"tag":"li","lines":"132,180"}}],"payload":{"tag":"li","lines":"119,180"}}],"payload":{"tag":"li","lines":"108,180"}},{"content":"<strong>Using Pattern Matching with Records</strong><br>\nNew to Java 21, records have been updated to support pattern matching. Initially,<br>\nyou might think this is not actually something new. After all, we could use records<br>\nwith pattern matching in Java 17. The new feature is really about the members of<br>\nthe record, rather than the record itself.","children":[{"content":"Let&#x2019;s try an example:<pre data-lines=\"186,199\"><code class=\"language-java\"><span class=\"hljs-number\">1</span>: <span class=\"hljs-keyword\">record</span> <span class=\"hljs-title class_\">Monkey</span><span class=\"hljs-params\">(String name, <span class=\"hljs-type\">int</span> age)</span> {}\n<span class=\"hljs-number\">2</span>:\n<span class=\"hljs-number\">3</span>: <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Zoo</span> {\n<span class=\"hljs-number\">4</span>:   <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> {\n<span class=\"hljs-number\">5</span>:\n<span class=\"hljs-number\">6</span>:     <span class=\"hljs-type\">Object</span> <span class=\"hljs-variable\">animal</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Monkey</span>(<span class=\"hljs-string\">&quot;George&quot;</span>, <span class=\"hljs-number\">3</span>);\n<span class=\"hljs-number\">7</span>:      <span class=\"hljs-comment\">//animal instanceof Monkey m</span>\n<span class=\"hljs-number\">8</span>:     <span class=\"hljs-keyword\">if</span>(animal <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-title function_\">Monkey</span><span class=\"hljs-params\">(String name, <span class=\"hljs-type\">int</span> myAge)</span>) {\n<span class=\"hljs-number\">9</span>:       System.out.println(<span class=\"hljs-string\">&quot;Hello &quot;</span> + name);\n<span class=\"hljs-number\">10</span>:      System.out.println(<span class=\"hljs-string\">&quot;Your age is &quot;</span> + myAge);\n<span class=\"hljs-number\">11</span>: } } }\n</code></pre>","children":[{"content":"Wait, what&#x2019;s going on in line 8? It looks like we redeclared the declaration of the<br>\nrecord. Don&#x2019;t worry, we didn&#x2019;t! What we did do, though, is define a pattern that is<br>\ncompatible with the <code>Monkey</code> record. We also named two elements, <code>name</code> and<br>\n<code>myAge</code> (this is not mandatory). This allows us to use them as local variables on<br>\nline 9 and 10, without a reference variable.","children":[{"content":"For the exam, you should be aware of the following rules when working with pattern<br>\nmatching and records:<br>\n* If any field declared in the record is included, then all fields must be included.<br>\n* The order of fields must be the same as in the record.<br>\n* The names of the fields do not have to match.<br>\n* At compile time, the type of the field must be compatible with the type declared in the record.<br>\n* The pattern may not match at runtime if the record<br>\nsupports elements of various types.","children":[{"content":"Working with records and pattern matching has some similarities to casting. For<br>\nexample, the compiler will disallow things that it knows to be invalid. There are<br>\nsome differences, though, that we will get to shortly.<br>\nQuiz time! Given our previous <code>Monkey</code> record, which of the following lines of<br>\ncode do not compile?<pre data-lines=\"217,223\"><code class=\"language-java\"><span class=\"hljs-number\">11</span>: <span class=\"hljs-keyword\">if</span>(animal <span class=\"hljs-keyword\">instanceof</span> Monkey myMonkey) {}\n<span class=\"hljs-number\">12</span>: <span class=\"hljs-keyword\">if</span>(animal <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-title function_\">Monkey</span><span class=\"hljs-params\">(String n, <span class=\"hljs-type\">int</span> a)</span> myMonkey) {}\n<span class=\"hljs-number\">13</span>: <span class=\"hljs-keyword\">if</span>(animal <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-title function_\">Monkey</span><span class=\"hljs-params\">(String n, <span class=\"hljs-type\">long</span> a)</span>) {}\n<span class=\"hljs-number\">14</span>: <span class=\"hljs-keyword\">if</span>(animal <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-title function_\">Monkey</span><span class=\"hljs-params\">(Object n, <span class=\"hljs-type\">int</span> a)</span>) {}\n</code></pre>","children":[{"content":"The first example compiles, as this is just simple pattern matching. Line 12 does<br>\nnot compile, though. <strong style=\"color:green\">You can name the record or its fields, but not both</strong>. Line<br>\n13 also does not compile, as <strong style=\"color:green\">numeric promotion is not supported</strong>. The last<br>\nline does  compile, as <strong style=\"color:green\"><code>String</code> is compatible with <code>Object</code></strong>.","children":[{"content":"<strong>Matching Records</strong><br>\nThe last two rules for record matching warrant a bit more discussion. Pattern matching for<br>\nrecords include matching both the type of the record the type of each field. Given the five<br>\npattern matching statements, what does the following code print?","children":[{"content":"\n<pre data-lines=\"231,254\"><code class=\"language-java\"><span class=\"hljs-number\">1</span>: <span class=\"hljs-keyword\">record</span> <span class=\"hljs-title class_\">Fish</span><span class=\"hljs-params\">(Object type)</span> {}\n<span class=\"hljs-number\">2</span>: <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Veterinarian</span> {\n<span class=\"hljs-number\">3</span>:   <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> {\n<span class=\"hljs-number\">4</span>:     <span class=\"hljs-type\">Fish</span> <span class=\"hljs-variable\">f1</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Fish</span>(<span class=\"hljs-string\">&quot;Nemo&quot;</span>);\n<span class=\"hljs-number\">5</span>:     <span class=\"hljs-type\">Fish</span> <span class=\"hljs-variable\">f2</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Fish</span>(Integer.valueOf(<span class=\"hljs-number\">1</span>));\n<span class=\"hljs-number\">6</span>:\n<span class=\"hljs-number\">7</span>:     <span class=\"hljs-keyword\">if</span>(f1 <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-title function_\">Fish</span><span class=\"hljs-params\">(Object t)</span>) {\n<span class=\"hljs-number\">8</span>:       System.out.print(<span class=\"hljs-string\">&quot;Match1-&quot;</span>);\n<span class=\"hljs-number\">9</span>:     }\n<span class=\"hljs-number\">10</span>:    <span class=\"hljs-keyword\">if</span>(f1 <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-title function_\">Fish</span><span class=\"hljs-params\">(String t)</span>) {\n<span class=\"hljs-number\">11</span>:      System.out.print(<span class=\"hljs-string\">&quot;Match2-&quot;</span>);\n<span class=\"hljs-number\">12</span>:    }\n<span class=\"hljs-number\">13</span>:    <span class=\"hljs-keyword\">if</span>(f1 <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-title function_\">Fish</span><span class=\"hljs-params\">(Integer t)</span>) {\n<span class=\"hljs-number\">14</span>:      System.out.print(<span class=\"hljs-string\">&quot;Match3-&quot;</span>);\n<span class=\"hljs-number\">15</span>:    }\n<span class=\"hljs-number\">16</span>:    <span class=\"hljs-keyword\">if</span>(f2 <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-title function_\">Fish</span><span class=\"hljs-params\">(String t)</span>) {\n<span class=\"hljs-number\">17</span>:      System.out.print(<span class=\"hljs-string\">&quot;Match4-&quot;</span>);\n<span class=\"hljs-number\">18</span>:    }\n<span class=\"hljs-number\">19</span>:    <span class=\"hljs-keyword\">if</span>(f2 <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-title function_\">Fish</span><span class=\"hljs-params\">(Integer x)</span>) {\n<span class=\"hljs-number\">20</span>:      System.out.print(<span class=\"hljs-string\">&quot;Match5&quot;</span>);\n<span class=\"hljs-number\">21</span>:    } } }\n</code></pre>","children":[{"content":"The first and second pattern matching statements match because <code>&quot;Nemo&quot;</code> can be implicitly cast to <code>Object</code><br>\nand <code>String</code>, respectively. The third statement compiles but does not match, as <code>&quot;Nemo&quot;</code> cannot be cast to<br>\n<code>Integer</code>. Likewise, the fourth statement compiles but does not match, as the numeric value cannot be cast<br>\nto <code>String</code>. Finally, the last statement matches as the type of both is <code>Integer</code>. The code compiles and prints<br>\nthe following at runtime:<pre data-lines=\"259,262\"><code class=\"language-java\">Match1-Match2-Match5\n</code></pre>","children":[],"payload":{"tag":"li","lines":"254,262"}},{"content":"What happens if we change the declaration of <code>Fish</code> to the following?<pre data-lines=\"263,266\"><code class=\"language-java\"><span class=\"hljs-number\">1</span>: <span class=\"hljs-keyword\">record</span> <span class=\"hljs-title class_\">Fish</span><span class=\"hljs-params\">(Integer type)</span> {}\n</code></pre>\nFirst off, our <code>f1</code> variable declared on line 4 would no longer compile! Assuming we fix the variable declaration,<br>\nthough, lines 10 and 16 would not compile. The compiler is smart enough to know that no instance of <code>Fish</code><br>\nis capable of matching an <code>Integer</code> to a <code>String</code>.","children":[],"payload":{"tag":"li","lines":"262,269"}}],"payload":{"tag":"li","lines":"231,269"}}],"payload":{"tag":"li","lines":"227,269"}}],"payload":{"tag":"li","lines":"223,269"}}],"payload":{"tag":"li","lines":"212,269"}}],"payload":{"tag":"li","lines":"204,269"}}],"payload":{"tag":"li","lines":"199,269"}}],"payload":{"tag":"li","lines":"185,269"}}],"payload":{"tag":"li","lines":"180,269"}},{"content":"<strong>Nesting Record Patterns</strong><br>\nIf a record includes other record values as members, then you can optionally pattern match<br>\nthe fields within the record. Ready to see how this works? Let&#x2019;s start with two records.<pre data-lines=\"272,276\"><code class=\"language-java\"><span class=\"hljs-keyword\">record</span> <span class=\"hljs-title class_\">Bear</span><span class=\"hljs-params\">(String name, List&lt;String&gt; favoriteThings)</span> {}\n<span class=\"hljs-keyword\">record</span> <span class=\"hljs-title class_\">Couple</span><span class=\"hljs-params\">(Bear a, Bear b)</span> {}\n</code></pre>","children":[{"content":"Now, let&#x2019;s say we define a <code>Couple</code> instance within a method.<pre data-lines=\"277,280\"><code class=\"language-java\"><span class=\"hljs-type\">var</span> <span class=\"hljs-variable\">c</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Couple</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Bear</span>(<span class=\"hljs-string\">&quot;Yogi&quot;</span>, List.of(<span class=\"hljs-string\">&quot;PicnicBaskets&quot;</span>)), <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Bear</span>(<span class=\"hljs-string\">&quot;Fozzie&quot;</span>, List.of(<span class=\"hljs-string\">&quot;BadJokes&quot;</span>)));\n</code></pre>\nWhich of the following pattern matching statements compile?<pre data-lines=\"281,292\"><code class=\"language-java\"><span class=\"hljs-keyword\">if</span>(c <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-title function_\">Couple</span><span class=\"hljs-params\">(Bear a, Bear b)</span>) {\n  System.out.print(a.name() + <span class=\"hljs-string\">&quot; &quot;</span> + b.name());\n}\n<span class=\"hljs-keyword\">if</span>(c <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-title function_\">Couple</span><span class=\"hljs-params\">(Bear(String firstName, List&lt;String&gt; f)</span>, Bear b)) {\n  System.out.print(firstName + <span class=\"hljs-string\">&quot; &quot;</span> + b.name());\n}\n<span class=\"hljs-keyword\">if</span>(c <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-title function_\">Couple</span><span class=\"hljs-params\">(Bear(String name, List&lt;String&gt; f1)</span>, Bear(String name, List&lt;String&gt; f2))) {\n  System.out.print(name + <span class=\"hljs-string\">&quot; &quot;</span> + name);\n}\n</code></pre>","children":[{"content":"The first pattern matching statement compiles and uses <code>Couple</code> without expanding the nested <code>Bear</code> records. The<br>\nsecond example expands the first <code>Bear</code> record, making <code>firstName</code>, <code>f</code> and <code>b</code> local variables within the pattern matching<br>\nstatement. The third pattern matching statement does not compile. Although you can expand both records, <strong style=\"color:green\">you have<br>\nto give them distinct names</strong>. We can fix this, though, by expanding the nested types to have unique names.<pre data-lines=\"296,301\"><code class=\"language-java\"><span class=\"hljs-keyword\">if</span>(c <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-title function_\">Couple</span><span class=\"hljs-params\">(Bear(String n1, List&lt;String&gt; f1)</span>, Bear(String n2, List&lt;String&gt; f2))) {\n  System.out.print(n1 + <span class=\"hljs-string\">&quot; &quot;</span> + n2);\n}\n</code></pre>","children":[{"content":"<strong>Matching Records with <em><code>var</code></em> and Generics</strong><br>\nYou can also use <code>var</code> in a pattern matching record. Let&#x2019;s apply this to our previous examples.<pre data-lines=\"303,313\"><code class=\"language-java\"><span class=\"hljs-type\">var</span> <span class=\"hljs-variable\">c</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Couple</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Bear</span>(<span class=\"hljs-string\">&quot;Yogi&quot;</span>, List.of(<span class=\"hljs-string\">&quot;PicnicBaskets&quot;</span>)),\n<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Bear</span>(<span class=\"hljs-string\">&quot;Fozzie&quot;</span>, List.of(<span class=\"hljs-string\">&quot;BadJokes&quot;</span>)));\n<span class=\"hljs-keyword\">if</span> (c <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-title function_\">Couple</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">var</span> a, <span class=\"hljs-keyword\">var</span> b)</span>) {\n  System.out.print(a.name() + <span class=\"hljs-string\">&quot; &quot;</span> + b.name());\n}\n<span class=\"hljs-keyword\">if</span> (c <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-title function_\">Couple</span><span class=\"hljs-params\">(Bear(<span class=\"hljs-keyword\">var</span> firstName, List&lt;String&gt; f)</span>, <span class=\"hljs-keyword\">var</span> b)) {\n  System.out.print(firstName + <span class=\"hljs-string\">&quot; &quot;</span> + b.name());\n}\n</code></pre>","children":[{"content":"As you can see, you can replace any element reference type with <code>var</code>. <strong>When <code>var</code> is used for one<br>\nof the elements of the record, the compiler assumes the type to be the exact match for the<br>\ntype in the record.</strong>","children":[{"content":"Pattern matching generics within records follow the similar rules for overloading generic<br>\nmethods. Let&#x2019;s try a few examples, though, to see the kinds of things that exam might<br>\nthrow at you. Each of the following compiles without issue:<pre data-lines=\"319,326\"><code class=\"language-java\"><span class=\"hljs-keyword\">if</span>(c <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-title function_\">Couple</span><span class=\"hljs-params\">(Bear(<span class=\"hljs-keyword\">var</span> n, Object f)</span>, <span class=\"hljs-keyword\">var</span> b)) {}\n<span class=\"hljs-keyword\">if</span>(c <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-title function_\">Couple</span><span class=\"hljs-params\">(Bear(<span class=\"hljs-keyword\">var</span> n, List f)</span>, <span class=\"hljs-keyword\">var</span> b)) {}\n<span class=\"hljs-keyword\">if</span>(c <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-title function_\">Couple</span><span class=\"hljs-params\">(Bear(<span class=\"hljs-keyword\">var</span> n, List&lt;?&gt; f)</span>, <span class=\"hljs-keyword\">var</span> b)) {}\n<span class=\"hljs-keyword\">if</span>(c <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-title function_\">Couple</span><span class=\"hljs-params\">(Bear(<span class=\"hljs-keyword\">var</span> n, List&lt;? extends Object&gt; f)</span>, <span class=\"hljs-keyword\">var</span> b)) {}\n<span class=\"hljs-keyword\">if</span>(c <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-title function_\">Couple</span><span class=\"hljs-params\">(Bear(<span class=\"hljs-keyword\">var</span> n, ArrayList&lt;String&gt; f)</span>, <span class=\"hljs-keyword\">var</span> b)) {}\n</code></pre>","children":[{"content":"There are limits, though. For example, the following two examples do not compile:<pre data-lines=\"327,331\"><code class=\"language-java\"><span class=\"hljs-keyword\">if</span>(c <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-title function_\">Couple</span><span class=\"hljs-params\">(Bear(<span class=\"hljs-keyword\">var</span> n, List&lt;&gt; f)</span>, <span class=\"hljs-keyword\">var</span> b)) {}\n<span class=\"hljs-keyword\">if</span>(c <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-title function_\">Couple</span><span class=\"hljs-params\">(Bear(<span class=\"hljs-keyword\">var</span> n, List&lt;Object&gt; f)</span>, <span class=\"hljs-keyword\">var</span> b)) {}\n</code></pre>","children":[{"content":"The first example does not compile because the diamond operator (<code>&lt;&gt;</code>) cannot be used for<br>\npattern matching (nor overloading generics). The second example does not compile because<br>\n<code>List&lt;Object&gt;</code> is not compatible with <code>List&lt;String&gt;</code>. This would also not compile if these types<br>\nwere applied to method parameters of inherited methods, due to type erasure.","children":[],"payload":{"tag":"li","lines":"331,335"}}],"payload":{"tag":"li","lines":"326,335"}}],"payload":{"tag":"li","lines":"316,335"}}],"payload":{"tag":"li","lines":"313,335"}}],"payload":{"tag":"li","lines":"301,335"}}],"payload":{"tag":"li","lines":"292,335"}}],"payload":{"tag":"li","lines":"276,335"}}],"payload":{"tag":"li","lines":"269,335"}},{"content":"In these examples, remember that <code>f</code> is the pattern type, not the original <code>List&lt;String&gt;</code>. Given<br>\nthis, can  you deduce why this code does not compile?<pre data-lines=\"337,343\"><code class=\"language-java\"><span class=\"hljs-keyword\">if</span>(c <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-title function_\">Couple</span><span class=\"hljs-params\">(Bear(<span class=\"hljs-keyword\">var</span> n, List f)</span>, <span class=\"hljs-keyword\">var</span> b)\n      &amp;&amp; f.getFirst().toLowerCase().contains(<span class=\"hljs-string\">&quot;p&quot;</span>)) { <span class=\"hljs-comment\">// DOES NOT COMPILE</span>\n  System.out.print(<span class=\"hljs-string\">&quot;Yummy&quot;</span>);\n}\n</code></pre>","children":[{"content":"The reference type of <code>f</code> is <code>List</code>, not <code>List&lt;String&gt;</code>, therefore <code>f.getFirst()</code> returns an <code>Object</code><br>\nreference, not a <code>String</code> reference. Since <code>toLowerCase()</code> is not defined on <code>Object</code>, the<br>\ncode does not compile. To compile you would either have to explicitly cast it to a <code>String</code><br>\nor use a different pattern matching type.","children":[{"content":"<strong>Applying Pattern Matching Records to Switch</strong><br>\nIt might not be a surprise that you can use switch with pattern matching and records. The<br>\nrules are the same as you&#x2019;ve already learned, we&#x2019;re just combing the <code>switch</code> pattern<br>\nmatching rules you learned about in Chapter 3 with what we covered in this chapter.<br>\nLet&#x2019;s say we have a <code>Snake</code> record as follows:<pre data-lines=\"352,355\"><code class=\"language-java\"><span class=\"hljs-keyword\">record</span> <span class=\"hljs-title class_\">Snake</span><span class=\"hljs-params\">(Object data)</span> {}\n</code></pre>","children":[{"content":"Next, let&#x2019;s construct a method that operates on an instance of <code>Snake</code>.<pre data-lines=\"356,366\"><code class=\"language-java\"><span class=\"hljs-type\">long</span> <span class=\"hljs-title function_\">showData</span><span class=\"hljs-params\">(Snake snake)</span> {\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">switch</span>(snake) {\n    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-title function_\">Snake</span><span class=\"hljs-params\">(Long hiss)</span>-&gt; hiss + <span class=\"hljs-number\">1</span>;\n    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-title function_\">Snake</span><span class=\"hljs-params\">(Integer nagina)</span> -&gt; nagina + <span class=\"hljs-number\">10</span>;\n    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-title function_\">Snake</span><span class=\"hljs-params\">(Number crowley)</span> -&gt; crowley.intValue() + <span class=\"hljs-number\">100</span>;\n    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-title function_\">Snake</span><span class=\"hljs-params\">(Object kaa)</span> -&gt; -<span class=\"hljs-number\">1</span>; <span class=\"hljs-comment\">//required</span>\n  }; <span class=\"hljs-comment\">//required semicolon</span>\n}\n</code></pre>","children":[{"content":"As you might recall, a <code>default</code> clause is not required if all types are covered in the pattern  matching<br>\nexpression. Given this code, see if you can follow the output generated by each of these examples:<pre data-lines=\"368,373\"><code class=\"language-java\">System.out.println(showData(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Snake</span>(<span class=\"hljs-number\">1</span>)));   <span class=\"hljs-comment\">// 11</span>\nSystem.out.println(showData(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Snake</span>(<span class=\"hljs-number\">2L</span>)));  <span class=\"hljs-comment\">// 3</span>\nSystem.out.println(showData(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Snake</span>(<span class=\"hljs-number\">3.0</span>))); <span class=\"hljs-comment\">// 103</span>\n</code></pre>","children":[{"content":"Remember, the type matters for any associated <code>when</code> clauses. For example, the following does<br>\nnot compile since <code>kaa</code> is of type <code>Object</code>, which does not have a<code> doubleValue()</code> method:<pre data-lines=\"375,383\"><code class=\"language-java\"><span class=\"hljs-type\">long</span> <span class=\"hljs-title function_\">showData</span><span class=\"hljs-params\">(Snake snake)</span> {\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">switch</span>(snake) {\n    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-title function_\">Snake</span><span class=\"hljs-params\">(Object kaa)</span> <span class=\"hljs-keyword\">when</span> kaa.doubleValue() &gt; <span class=\"hljs-number\">0</span> -&gt; -<span class=\"hljs-number\">1</span>;\n    <span class=\"hljs-keyword\">default</span> -&gt; <span class=\"hljs-number\">1_000</span>; <span class=\"hljs-comment\">//(In normal pattern matching is not allowed)</span>\n  };\n}\n</code></pre>","children":[],"payload":{"tag":"li","lines":"373,383"}}],"payload":{"tag":"li","lines":"366,383"}}],"payload":{"tag":"li","lines":"355,383"}}],"payload":{"tag":"li","lines":"347,383"}}],"payload":{"tag":"li","lines":"343,383"}}],"payload":{"tag":"li","lines":"335,383"}},{"content":"<strong>Customizing Records</strong><br>\nSince records are data-oriented, we&#x2019;ve focused on the features of records you are likely to use.<br>\nRecords actually support many of the same features as a class. Here are some of the members<br>\nthat records can include and that you should be familiar with for the exam:","children":[{"content":"* Overloaded and compact constructors<br>\n* Instance methods including overriding any provided methods (accessors, <code>equals()</code>, <code>hashCode()</code>, <code>toString()</code>)<br>\n* Nested classes, interfaces, annotations, enums, and records","children":[{"content":"As an illustrative example, the following overrides two instance methods<br>\nusing the optional <code>@Override</code> annotation:<pre data-lines=\"392,398\"><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">record</span> <span class=\"hljs-title class_\">Crane</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> numberEggs, String name)</span> {\n  <span class=\"hljs-meta\">@Override</span> <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">numberEggs</span><span class=\"hljs-params\">()</span> { <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">10</span>; }\n  <span class=\"hljs-meta\">@Override</span> <span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title function_\">toString</span><span class=\"hljs-params\">()</span> { <span class=\"hljs-keyword\">return</span> name; }\n}\n</code></pre>","children":[{"content":"While you can add methods, <code>static</code> fields, and other data types, <strong style=\"color:green\">you cannot<br>\nadd instance fields outside the record declaration.</strong><pre data-lines=\"400,407\"><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">record</span> <span class=\"hljs-title class_\">Crane</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> numberEggs, String name)</span> {\n  <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">TYPE</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">10</span>;\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">int</span> size; <span class=\"hljs-comment\">// DOES NOT COMPILE</span>\n  <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">boolean</span> <span class=\"hljs-variable\">friendly</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">true</span>; <span class=\"hljs-comment\">// DOES NOT COMPILE</span>\n}\n</code></pre>","children":[{"content":"<strong style=\"color:green\">Records also do not support instance initializers</strong>. All initialization for the fields of a<br>\nrecord must happen in a constructor. They do support static initializers, though.<pre data-lines=\"409,416\"><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">record</span> <span class=\"hljs-title class_\">Crane</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> numberEggs, String name)</span> {\n  <span class=\"hljs-keyword\">static</span> { System.out.print(<span class=\"hljs-string\">&quot;Hello Bird!&quot;</span>); }\n  { System.out.print(<span class=\"hljs-string\">&quot;Goodbye Bird!&quot;</span>); } <span class=\"hljs-comment\">// DOES NOT COMPILE</span>\n  { <span class=\"hljs-built_in\">this</span>.name = <span class=\"hljs-string\">&quot;Big&quot;</span>; } <span class=\"hljs-comment\">// DOES NOT COMPILE</span>\n}\n</code></pre>\nIn this example, the first initializer compiles because it is <code>static</code>, while the second and<br>\nthird do not because they are instance initializers.","children":[],"payload":{"tag":"li","lines":"407,418"}}],"payload":{"tag":"li","lines":"398,418"}}],"payload":{"tag":"li","lines":"390,418"}}],"payload":{"tag":"li","lines":"387,418"}}],"payload":{"tag":"li","lines":"383,418"}}],"payload":{"tag":"h1","lines":"5,6"}},{"initialExpandLevel":1})</script>
</body>
</html>
