<!doctype html>
<html>
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta http-equiv="X-UA-Compatible" content="ie=edge" />
<title>Markmap</title>
<style>
* {
  margin: 0;
  padding: 0;
}
html {
  font-family: ui-sans-serif, system-ui, sans-serif, 'Apple Color Emoji',
    'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji';
}
#mindmap {
  display: block;
  width: 100vw;
  height: 100vh;
}
.markmap-dark {
  background: #27272a;
  color: white;
}
</style>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/markmap-toolbar@0.18.12/dist/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@highlightjs/cdn-assets@11.11.1/styles/default.min.css">
</head>
<body>
<svg id="mindmap"></svg>
<script src="https://cdn.jsdelivr.net/npm/d3@7.9.0/dist/d3.min.js"></script><script src="https://cdn.jsdelivr.net/npm/markmap-view@0.18.12/dist/browser/index.js"></script><script src="https://cdn.jsdelivr.net/npm/markmap-toolbar@0.18.12/dist/index.js"></script><script>(r => {
              setTimeout(r);
            })(function renderToolbar() {
  const {
    markmap,
    mm
  } = window;
  const {
    el
  } = markmap.Toolbar.create(mm);
  el.setAttribute('style', 'position:absolute;bottom:20px;right:20px');
  document.body.append(el);
})</script><script>((getMarkmap, getOptions, root2, jsonOptions) => {
              const markmap = getMarkmap();
              window.mm = markmap.Markmap.create(
                "svg#mindmap",
                (getOptions || markmap.deriveOptions)(jsonOptions),
                root2
              );
              if (window.matchMedia("(prefers-color-scheme: dark)").matches) {
                document.documentElement.classList.add("markmap-dark");
              }
            })(() => window.markmap,null,{"content":"<strong>Using Method References</strong>","children":[{"content":"Method references are another way to make the code easier<br>\nto read, such as simply mentioning the name of the method.","children":[{"content":"Consider the following functional interface:<pre data-lines=\"9,14\"><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">LearnToSpeak</span> {\n  <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">speak</span><span class=\"hljs-params\">(String sound)</span>;\n}\n</code></pre>","children":[{"content":"Using lambdas<pre data-lines=\"15,18\"><code class=\"language-java\">LearnToSpeak learner=s -&#xad;&gt; System.out.println(s);\n</code></pre>","children":[],"payload":{"tag":"li","lines":"14,18"}},{"content":"Usig method reference<pre data-lines=\"19,22\"><code class=\"language-java\">LearnToSpeak learner=System.out::println;\n</code></pre>","children":[],"payload":{"tag":"li","lines":"18,22"}},{"content":"The <strong><code>::</code></strong> operator tells Java to call the <code>println()</code> method later.","children":[],"payload":{"tag":"li","lines":"22,23"}}],"payload":{"tag":"li","lines":"8,23"}}],"payload":{"tag":"li","lines":"6,23"}},{"content":"<strong>Calling <code>static</code> Methods</strong>","children":[{"content":"We use a functional interface that converts a <code>double</code> to a <code>long</code>:<pre data-lines=\"25,30\"><code class=\"language-java\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">Converter</span> {\n  <span class=\"hljs-type\">long</span> <span class=\"hljs-title function_\">round</span><span class=\"hljs-params\">(<span class=\"hljs-type\">double</span> num)</span>;\n}\n</code></pre>","children":[],"payload":{"tag":"li","lines":"24,30"}},{"content":"\n<pre data-lines=\"30,36\"><code class=\"language-java\"><span class=\"hljs-number\">14</span>: <span class=\"hljs-type\">Converter</span> <span class=\"hljs-variable\">methodRef</span> <span class=\"hljs-operator\">=</span> Math::round;\n<span class=\"hljs-number\">15</span>: <span class=\"hljs-type\">Converter</span> <span class=\"hljs-variable\">lambda</span> <span class=\"hljs-operator\">=</span> x -&gt; Math.round(x);\n<span class=\"hljs-number\">16</span>:\n<span class=\"hljs-number\">17</span>: System.out.println(methodRef.round(<span class=\"hljs-number\">100.1</span>)); <span class=\"hljs-comment\">// 100</span>\n</code></pre>","children":[{"content":"On line 14, we reference a method with one parameter, and Java knows that it&#x2019;s like a lambda with one<br>\nparameter. Additionally, Java knows to pass that parameter to the method.<br>\nWait a minute. You might be aware that the <code>round()</code> method is overloaded&#x2014;&#xad;it can take a <code>double</code> or a<br>\n<code>float</code> and returns <code>long</code> or <code>int</code>. How does Java know that we want to call the version with a <code>double</code>?<br>\nWith both lambdas and method references, Java infers information from the <em>context</em>. In this case, we<br>\nsaid that we were declaring a <code>Converter</code>, which has a method taking a <code>double</code> parameter. <strong>Java looks<br>\nfor a method that matches that description. If it can&#x2019;t find it or finds multiple matches, then<br>\nthe compiler will report an error. The latter is sometimes called an <em>ambiguous</em> type error.</strong>","children":[],"payload":{"tag":"li","lines":"36,44"}}],"payload":{"tag":"li","lines":"30,44"}}],"payload":{"tag":"li","lines":"23,44"}},{"content":"<strong>Calling Instance Methods<br>\non a Particular Object</strong>","children":[{"content":"\n<p data-lines=\"46,48\">We have a functional interface that checks if a<br>\n<code>String</code> starts with a specified value:</p>\n<pre data-lines=\"48,53\"><code class=\"language-java\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">StringStart</span> {\n  <span class=\"hljs-type\">boolean</span> <span class=\"hljs-title function_\">beginningCheck</span><span class=\"hljs-params\">(String prefix)</span>;\n}\n</code></pre>","children":[],"payload":{"tag":"li","lines":"46,53"}},{"content":"\n<pre data-lines=\"53,60\"><code class=\"language-java\"><span class=\"hljs-number\">18</span>: <span class=\"hljs-type\">var</span> <span class=\"hljs-variable\">str</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;Zoo&quot;</span>; <span class=\"hljs-comment\">//effectively final or final</span>\n<span class=\"hljs-number\">19</span>: <span class=\"hljs-type\">StringStart</span> <span class=\"hljs-variable\">methodRef</span> <span class=\"hljs-operator\">=</span> str::startsWith;\n<span class=\"hljs-number\">20</span>: <span class=\"hljs-type\">StringStart</span> <span class=\"hljs-variable\">lambda</span> <span class=\"hljs-operator\">=</span> s -&gt; str.startsWith(s);\n<span class=\"hljs-number\">21</span>:\n<span class=\"hljs-number\">22</span>: System.out.println(methodRef.beginningCheck(<span class=\"hljs-string\">&quot;A&quot;</span>)); <span class=\"hljs-comment\">// false</span>\n</code></pre>","children":[{"content":"Line 19 shows that we want to call <code>str.startsWith()</code> and<br>\npass a single parameter to be supplied at runtime","children":[],"payload":{"tag":"li","lines":"60,62"}}],"payload":{"tag":"li","lines":"53,62"}},{"content":"\n<p data-lines=\"62,64\">In this example, we create a functional interface with a method<br>\nthat doesn&#x2019;t take any parameters but returns a value:</p>\n<pre data-lines=\"64,69\"><code class=\"language-java\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">StringChecker</span> {\n  <span class=\"hljs-type\">boolean</span> <span class=\"hljs-title function_\">check</span><span class=\"hljs-params\">()</span>;\n}\n</code></pre>","children":[],"payload":{"tag":"li","lines":"62,69"}},{"content":"\n<p data-lines=\"69,70\">We implement it by checking if the <code>String</code> is empty:</p>\n<pre data-lines=\"70,77\"><code class=\"language-java\"><span class=\"hljs-number\">18</span>: <span class=\"hljs-type\">var</span> <span class=\"hljs-variable\">str</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;&quot;</span>;\n<span class=\"hljs-number\">19</span>: <span class=\"hljs-type\">StringChecker</span> <span class=\"hljs-variable\">methodRef</span> <span class=\"hljs-operator\">=</span> str::isEmpty;\n<span class=\"hljs-number\">20</span>: <span class=\"hljs-type\">StringChecker</span> <span class=\"hljs-variable\">lambda</span> <span class=\"hljs-operator\">=</span> () -&gt; str.isEmpty();\n<span class=\"hljs-number\">21</span>:\n<span class=\"hljs-number\">22</span>: System.out.print(methodRef.check()); <span class=\"hljs-comment\">// true</span>\n</code></pre>","children":[{"content":"Since the method on <code>String</code> is an instance method, we call<br>\nthe method reference on an instance of the <code>String</code> class.","children":[],"payload":{"tag":"li","lines":"77,79"}}],"payload":{"tag":"li","lines":"69,79"}},{"content":"\n<p data-lines=\"79,81\">While all method references can be turned into lambdas, the opposite<br>\nis not always <code>true</code>. For example, consider this code:</p>\n<pre data-lines=\"82,86\"><code class=\"language-java\"><span class=\"hljs-type\">var</span> <span class=\"hljs-variable\">str</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;&quot;</span>;\n<span class=\"hljs-type\">StringChecker</span> <span class=\"hljs-variable\">lambda</span> <span class=\"hljs-operator\">=</span> () -&gt; str.startsWith(<span class=\"hljs-string\">&quot;Zoo&quot;</span>);\n</code></pre>","children":[{"content":"\n<p data-lines=\"86,87\">How might we write this as a method reference? You might try one of the following:</p>\n<pre data-lines=\"88,93\"><code class=\"language-java\"><span class=\"hljs-type\">StringChecker</span> <span class=\"hljs-variable\">methodReference</span> <span class=\"hljs-operator\">=</span> str::startsWith; <span class=\"hljs-comment\">// DOES NOT COMPILE</span>\n\n<span class=\"hljs-type\">StringChecker</span> <span class=\"hljs-variable\">methodReference</span> <span class=\"hljs-operator\">=</span> str::startsWith(<span class=\"hljs-string\">&quot;Zoo&quot;</span>); <span class=\"hljs-comment\">// DOES NOT COMPILE</span>\n</code></pre>","children":[],"payload":{"tag":"li","lines":"86,93"}},{"content":"\n<p data-lines=\"93,96\">Neither of these works! While we can pass the <code>str</code> as part of the method reference, there&#x2019;s<br>\nno way to pass the <code>&quot;Zoo&quot;</code> parameter with it. Therefore, it is not possible to write this lambda<br>\nas a method reference.</p>","children":[],"payload":{"tag":"li","lines":"93,96"}}],"payload":{"tag":"li","lines":"79,96"}}],"payload":{"tag":"li","lines":"44,96"}},{"content":"<strong>Calling Instance Methods on a Parameter</strong>","children":[{"content":"\n<pre data-lines=\"97,102\"><code data-lines=\"97,102\">interface StringParameterChecker {\n  <span class=\"hljs-function\"><span class=\"hljs-type\">boolean</span> <span class=\"hljs-title\">check</span><span class=\"hljs-params\">(<span class=\"hljs-type\">String</span> text)</span></span>;\n}\n</code></pre>\nWe can implement this functional interface as follows:<pre data-lines=\"103,109\"><code class=\"language-java\"><span class=\"hljs-number\">23</span>: <span class=\"hljs-type\">StringParameterChecker</span> <span class=\"hljs-variable\">methodRef</span> <span class=\"hljs-operator\">=</span> String::isEmpty;\n<span class=\"hljs-number\">24</span>: <span class=\"hljs-type\">StringParameterChecker</span> <span class=\"hljs-variable\">lambda</span> <span class=\"hljs-operator\">=</span> s-&gt;s.isEmpty();\n<span class=\"hljs-number\">25</span>:\n<span class=\"hljs-number\">26</span>: System.out.println(methodRef.check(<span class=\"hljs-string\">&quot;Zoo&quot;</span>)); <span class=\"hljs-comment\">// false</span>\n</code></pre>","children":[{"content":"Line 23 says the method that we want to call is declared in <code>String</code>. It looks like a <code>static</code> method, but it<br>\nisn&#x2019;t. Instead, Java knows that <code>isEmpty()</code> is an instance method that does not take any parameters.<br>\nJava uses the parameter supplied at runtime as the instance on which the method is called.<br>\nCompare lines 23 and 24 with lines 19 and 20 of our instance example. They look similar, although<br>\none references a local variable named <code>str</code>, while the other only references the functional interface<br>\nparameters.","children":[],"payload":{"tag":"li","lines":"109,115"}}],"payload":{"tag":"li","lines":"97,115"}},{"content":"\n<pre data-lines=\"115,120\"><code class=\"language-java\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">StringTwoParameterChecker</span> {\n  <span class=\"hljs-type\">boolean</span> <span class=\"hljs-title function_\">check</span><span class=\"hljs-params\">(String text, String prefix)</span>;\n}\n</code></pre>\nPay attention to the parameter order when reading the implementation:<pre data-lines=\"121,127\"><code class=\"language-java\"><span class=\"hljs-number\">26</span>: <span class=\"hljs-type\">StringTwoParameterChecker</span> <span class=\"hljs-variable\">methodRef</span> <span class=\"hljs-operator\">=</span> String::startsWith;\n<span class=\"hljs-number\">27</span>: <span class=\"hljs-type\">StringTwoParameterChecker</span> <span class=\"hljs-variable\">lambda</span> <span class=\"hljs-operator\">=</span> (s, p)-&gt; s.startsWith(p);\n<span class=\"hljs-number\">28</span>:\n<span class=\"hljs-number\">29</span>: System.out.println(methodRef.check(<span class=\"hljs-string\">&quot;Zoo&quot;</span>, <span class=\"hljs-string\">&quot;A&quot;</span>)); <span class=\"hljs-comment\">// false</span>\n</code></pre>","children":[{"content":"Since the functional interface takes two parameters, Java has to figure out what they<br>\nrepresent. The first one will always be the instance of the object for instance methods. Any<br>\nothers are to be method parameters.<br>\nRemember that line 26 may look like a <code>static</code> method, but it is really a method reference<br>\ndeclaring that the instance of the object will be specified later. Line 27 shows some of the<br>\npower of a method reference. We were able to replace two lambda parameters this time.","children":[],"payload":{"tag":"li","lines":"127,133"}}],"payload":{"tag":"li","lines":"115,133"}}],"payload":{"tag":"li","lines":"96,133"}},{"content":"<strong>Calling Constructors</strong>","children":[{"content":"A constructor reference is a special type of method reference that uses <code>new</code><br>\ninstead of a method and instantiates an object.","children":[],"payload":{"tag":"li","lines":"134,136"}},{"content":"\n<pre data-lines=\"136,141\"><code class=\"language-java\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">EmptyStringCreator</span> {\n  String <span class=\"hljs-title function_\">create</span><span class=\"hljs-params\">()</span>;\n}\n</code></pre>\nTo call this, we use <code>new</code> as if it were a method name:<pre data-lines=\"142,149\"><code class=\"language-java\"><span class=\"hljs-number\">30</span>: <span class=\"hljs-type\">EmptyStringCreator</span> <span class=\"hljs-variable\">methodRef</span> <span class=\"hljs-operator\">=</span> String::<span class=\"hljs-keyword\">new</span>;\n<span class=\"hljs-number\">31</span>: <span class=\"hljs-type\">EmptyStringCreator</span> <span class=\"hljs-variable\">lambda</span> <span class=\"hljs-operator\">=</span> ()-&gt; <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">String</span>();\n<span class=\"hljs-number\">32</span>:\n<span class=\"hljs-number\">33</span>: <span class=\"hljs-type\">var</span> <span class=\"hljs-variable\">myString</span> <span class=\"hljs-operator\">=</span> methodRef.create();\n<span class=\"hljs-number\">34</span>: System.out.println(myString.equals(<span class=\"hljs-string\">&quot;Snake&quot;</span>)); <span class=\"hljs-comment\">// false</span>\n</code></pre>","children":[],"payload":{"tag":"li","lines":"136,149"}},{"content":"\n<pre data-lines=\"149,154\"><code data-lines=\"149,154\"><span class=\"hljs-title class_\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">StringCopier</span> </span>{\n  <span class=\"hljs-keyword\">String</span> copy(<span class=\"hljs-keyword\">String</span> value);\n}\n</code></pre>\nIn the implementation, notice that line 32 in the following example has<br>\nthe same method reference as line 30 in the previous example:<pre data-lines=\"156,163\"><code class=\"language-java\"><span class=\"hljs-number\">32</span>: <span class=\"hljs-type\">StringCopier</span> <span class=\"hljs-variable\">methodRef</span> <span class=\"hljs-operator\">=</span> String::<span class=\"hljs-keyword\">new</span>;\n<span class=\"hljs-number\">33</span>: <span class=\"hljs-type\">StringCopier</span> <span class=\"hljs-variable\">lambda</span> <span class=\"hljs-operator\">=</span> x-&gt;<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">String</span>(x);\n<span class=\"hljs-number\">34</span>:\n<span class=\"hljs-number\">35</span>: <span class=\"hljs-type\">var</span> <span class=\"hljs-variable\">myString</span> <span class=\"hljs-operator\">=</span> methodRef.copy(<span class=\"hljs-string\">&quot;Zebra&quot;</span>);\n<span class=\"hljs-number\">36</span>: System.out.println(myString.equals(<span class=\"hljs-string\">&quot;Zebra&quot;</span>)); <span class=\"hljs-comment\">// true</span>\n</code></pre>","children":[{"content":"This means you can&#x2019;t always determine which method can be called by looking at the<br>\nmethod reference. Instead, you have to look at the context to see what parameters are<br>\nused and if there is a return type. In this example, Java sees that we are passing a<br>\n<code>String</code> parameter and calls the constructor of <code>String</code> that takes such a parameter.","children":[],"payload":{"tag":"li","lines":"163,167"}}],"payload":{"tag":"li","lines":"149,167"}}],"payload":{"tag":"li","lines":"133,167"}}],"payload":{"tag":"h1","lines":"5,6"}},{"initialExpandLevel":1})</script>
</body>
</html>
