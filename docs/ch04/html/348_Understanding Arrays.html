<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<title>Markmap</title>
<style>
* {
  margin: 0;
  padding: 0;
}
#mindmap {
  display: block;
  width: 100vw;
  height: 100vh;
}
</style>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@highlightjs/cdn-assets@11.11.1/styles/default.min.css">
</head>
<body>
<svg id="mindmap"></svg>
<script src="https://cdn.jsdelivr.net/npm/d3@7.9.0/dist/d3.min.js"></script><script src="https://cdn.jsdelivr.net/npm/markmap-view@0.18.10/dist/browser/index.js"></script><script src="https://cdn.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/index.js"></script><script>(r => {
              setTimeout(r);
            })(function renderToolbar() {
  const {
    markmap,
    mm
  } = window;
  const {
    el
  } = markmap.Toolbar.create(mm);
  el.setAttribute('style', 'position:absolute;bottom:20px;right:20px');
  document.body.append(el);
})</script><script>((getMarkmap, getOptions, root2, jsonOptions) => {
              const markmap = getMarkmap();
              window.mm = markmap.Markmap.create(
                "svg#mindmap",
                (getOptions || markmap.deriveOptions)(jsonOptions),
                root2
              );
            })(() => window.markmap,null,{"content":"<strong>Understanding Arrays</strong>","children":[{"content":"\n<p data-lines=\"6,8\">An array is an area of memory on the heap with space for a<br>\ndesignated number of elements</p>\n<pre data-lines=\"8,11\"><code class=\"language-java\"><span class=\"hljs-type\">char</span>[] letters;\n</code></pre>","children":[{"content":"Keep in mind that <code>letters</code> is a reference variable and not a<br>\nprimitive. The <code>char</code> type is a primitive. But <code>char</code> is what goes<br>\ninto the array and not the type of the array itself. The array<br>\nitself is of type <code>char[]</code>. You can mentally read the brackets<br>\n(<code>[]</code>) as &#x201c;array.&#x201d;","children":[{"content":"An array is an ordered list and can contain<br>\nduplicates.","children":[],"payload":{"tag":"li","lines":"16,18"}}],"payload":{"tag":"li","lines":"11,18"}}],"payload":{"tag":"li","lines":"6,18"}},{"content":"\n<p data-lines=\"18,22\"><strong>Creating an Array of Primitives</strong><br>\nThe <a href=\"https://1drv.ms/i/c/c83cfca51d5c2032/Ed4CH0WjwN9NqjsUK3OJAW4BfKitQC50FkChGIpz7a6yVQ?e=bHI9nb\">Figure 4.3</a>  shows the most common way to create an array.<br>\nIt specifies the type of the array (<code>int</code>) and the size (<code>3</code>). The<br>\nbrackets tell you this is an array.</p>","children":[{"content":"When you use this form to instantiate an array, all elements<br>\nare set to the default value for that type. The default value of<br>\nan <code>int</code> is <code>0</code>. Since <code>numbers</code> is a reference variable, it points<br>\nto the array object, as shown in <a href=\"https://1drv.ms/i/c/c83cfca51d5c2032/EdpwXex4-9pPsLWkmcZD-9kBiHTtq0sC7grumbVYHuKYWA?e=L1xG1z\">Figure 4.4</a> . As you can see,<br>\nthe default value for all the elements is <code>0</code>. Also, the indexes<br>\nstart with <code>0</code> and count up, just as they did for a <code>String</code>.","children":[{"content":"Another way to create an array is to specify all the elements<br>\nit should start out with.<pre data-lines=\"30,33\"><code class=\"language-java\"><span class=\"hljs-type\">int</span>[] moreNumbers = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">int</span>[] {<span class=\"hljs-number\">42</span>, <span class=\"hljs-number\">55</span>, <span class=\"hljs-number\">99</span>};\n</code></pre>\nIn this example, we also create an int array of size <code>3</code>. This<br>\ntime, we specify the initial values of those three elements<br>\ninstead of using the defaults. <a href=\"https://1drv.ms/i/c/c83cfca51d5c2032/Ea0HOvCqIjNKj4UV0WGISTcBAi3Z-4oCGpBvWbuApBWs8g?e=dBUAsZ\">Figure 4.5</a> shows what this<br>\narray looks like.","children":[{"content":"The array type is specified on the left side of the equal sign.<br>\nSince the initial values &#x200b;&#x200b;are also specified, Java already knows<br>\nthe type and size.             As a shortcut, Java lets you write this:<pre data-lines=\"40,43\"><code class=\"language-java\"><span class=\"hljs-type\">int</span>[] moreNumbers = {<span class=\"hljs-number\">42</span>, <span class=\"hljs-number\">55</span>, <span class=\"hljs-number\">99</span>};\n</code></pre>\nThis approach is called an anonymous array. It is anonymous<br>\nbecause you don&#x2019;t specify the type and size.","children":[{"content":"Finally, you can type the <code>[]</code> before or after the name, and<br>\nadding a space is optional. All five of these statements do<br>\nthe exact same thing:<pre data-lines=\"48,55\"><code class=\"language-java\"><span class=\"hljs-type\">int</span>[] numAnimals;\n<span class=\"hljs-type\">int</span> [] numAnimals2;\n<span class=\"hljs-type\">int</span> []numAnimals3;\n<span class=\"hljs-type\">int</span> numAnimals4[];\n<span class=\"hljs-type\">int</span> numAnimals5 [];\n</code></pre>","children":[{"content":"<strong>Multiple &#x201c;Arrays&#x201d; in Declarations</strong><br>\nWhat types of reference variables do you think the following<br>\ncode creates?<pre data-lines=\"58,61\"><code class=\"language-java\"><span class=\"hljs-type\">int</span>[] ids, types;\n</code></pre>\nThe correct answer is two variables of type <code>int[]</code>. This<br>\nseems logical enough. After all, <code>int a, b;</code> created two <code>int</code><br>\nvariables. What about this example?<pre data-lines=\"64,67\"><code class=\"language-java\"><span class=\"hljs-type\">int</span> ids[], types;\n</code></pre>","children":[{"content":"All we did was move the brackets, but it changed the behavior.<br>\nThis time we get one variable of type <code>int[]</code> and one variable of<br>\ntype <code>int</code>. Java sees this line of code and thinks something like<br>\nthis: &#x201c;They want two variables of type <code>int</code>. The first one is called<br>\n<code>ids[]</code>. This one is an <code>int[]</code> called <code>ids</code>. The second one is just<br>\ncalled <code>types</code>. No brackets,                          so it is a regular integer.&#x201d;","children":[],"payload":{"tag":"li","lines":"67,73"}}],"payload":{"tag":"li","lines":"55,73"}}],"payload":{"tag":"li","lines":"45,73"}}],"payload":{"tag":"li","lines":"37,73"}}],"payload":{"tag":"li","lines":"28,73"}}],"payload":{"tag":"li","lines":"22,73"}}],"payload":{"tag":"li","lines":"18,73"}},{"content":"\n<p data-lines=\"73,76\"><strong>Creating an Array with Reference Variables</strong><br>\nYou can choose any Java type to be the type of the array. Let&#x2019;s take a look at a<br>\nbuilt-in type with <code>String</code>:</p>\n<pre data-lines=\"76,84\"><code class=\"language-java\">String[] bugs = { <span class=\"hljs-string\">&quot;cricket&quot;</span>, <span class=\"hljs-string\">&quot;beetle&quot;</span>, <span class=\"hljs-string\">&quot;ladybug&quot;</span> };\nString[] alias = bugs;\nString[] anotherArray = { <span class=\"hljs-string\">&quot;cricket&quot;</span>, <span class=\"hljs-string\">&quot;beetle&quot;</span>, <span class=\"hljs-string\">&quot;ladybug&quot;</span> };\nSystem.out.println(bugs.equals(alias)); <span class=\"hljs-comment\">// true</span>\nSystem.out.println(bugs.equals(anotherArray)); <span class=\"hljs-comment\">// false</span>\nSystem.out.println(bugs.toString()); <span class=\"hljs-comment\">// [Ljava.lang.String;@160bc7c0</span>\n</code></pre>","children":[{"content":"We can call <code>equals()</code> because an array is an object. The first<br>\ntest with <code>alias</code> returns <code>true</code> because of reference equality.<br>\nWhy does the second equality test return <code>false</code>? The <code>equals()</code><br>\nmethod on arrays does not look at the elements of the array.<br>\nThe second print statement is even more interesting. What on<br>\nEarth is <code>[Ljava.lang.String;@160bc7c0</code>? You don&#x2019;t have to know<br>\nthis for the exam, but <code>[L</code> means it is an array,<br>\n<code>java.lang.String</code> is the reference type, and <code>160bc7c0</code> is the hash<br>\ncode.","children":[{"content":"Java provides a method that prints an array nicely:<br>\n<code>Arrays.toString(bugs)</code> would print <code>[cricket, beetle, ladybug]</code>.","children":[],"payload":{"tag":"li","lines":"93,96"}},{"content":"We can see our <code>bugs</code> array represented in memory in <a href=\"https://1drv.ms/i/c/c83cfca51d5c2032/EQZs7NK-ebxAibs0AjMgaMEBc00CdhfMt96_smdpkUK9aQ?e=pvq6MF\">Figure<br>\n4.6</a>. Make sure you understand this figure. The array does not<br>\nallocate space for the <code>String</code> objects. Instead, it allocates space<br>\nfor a reference to where the objects are really stored.","children":[{"content":"As a quick review, what do you think this array points to?<pre data-lines=\"101,106\"><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Names</span> {\n  String names[];\n}\n</code></pre>\nThe answer is <code>null</code>. The code never instantiated the array,<br>\nso it is just a reference variable to <code>null</code>. Let&#x2019;s try that again:<br>\nwhat do you think this array                 points to?<pre data-lines=\"109,114\"><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Names</span> {\n  String names[] = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">String</span>[<span class=\"hljs-number\">2</span>];\n}\n</code></pre>","children":[{"content":"It is an array because it has brackets. It is an array of type<br>\n<code>String</code> since that is the type mentioned in the declaration. It<br>\nhas two elements because the length is <code>2</code>. Each of those<br>\ntwo slots currently is <code>null</code> but has the potential to point to a<br>\n<code>String</code> object.","children":[{"content":"\n<p data-lines=\"119,120\">You can use casting with arrays too:</p>\n<pre data-lines=\"120,127\"><code class=\"language-java\"><span class=\"hljs-number\">3</span>: String[] strings = { <span class=\"hljs-string\">&quot;stringValue&quot;</span> };\n<span class=\"hljs-number\">4</span>: Object[] objects = strings;\n<span class=\"hljs-number\">5</span>: String[] againStrings = (String[]) objects;\n<span class=\"hljs-number\">6</span>: againStrings[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">StringBuilder</span>(); <span class=\"hljs-comment\">// DOES NOT COMPILE</span>\n<span class=\"hljs-number\">7</span>: objects[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">StringBuilder</span>(); <span class=\"hljs-comment\">// Careful!</span>\n</code></pre>\n<p data-lines=\"127,131\">Line 3 creates an array of type <code>String</code>. Line 4 doesn&#x2019;t require a cast because<br>\n<code>Object</code> is a broader type than <code>String</code>. On line 5, a cast is needed because<br>\nwe are moving to a more specific type. Line 6 doesn&#x2019;t compile because a<br>\n<code>String[]</code> allows only <code>String</code> objects, and <code>StringBuilder</code> is not a <code>String</code>.</p>","children":[{"content":"Line 7 is where this gets interesting. From the point of view of the compiler,<br>\nthis is just fine. A <code>StringBuilder</code> object can clearly go in an <code>Object[]</code>. The<br>\nproblem is that we don&#x2019;t actually                          have an <code>Object[]</code>. We have a <code>String[]</code><br>\nreferred to from an <code>Object[]</code> variable. At runtime, the code throws an<br>\n<code>ArrayStoreException</code>. You don&#x2019;t need to memorize the name of this exception,<br>\nbut you do need to know that this line will compile and throw an exception.","children":[],"payload":{"tag":"li","lines":"132,138"}}],"payload":{"tag":"li","lines":"119,138"}}],"payload":{"tag":"li","lines":"114,138"}}],"payload":{"tag":"li","lines":"100,138"}}],"payload":{"tag":"li","lines":"96,138"}}],"payload":{"tag":"li","lines":"84,138"}}],"payload":{"tag":"li","lines":"73,138"}},{"content":"\n<p data-lines=\"138,140\"><strong>Using an Array</strong><br>\nNow that you know how to create an array, let&#x2019;s try accessing one:</p>\n<pre data-lines=\"140,147\"><code class=\"language-java\"><span class=\"hljs-number\">4</span>: String[] mammals = {<span class=\"hljs-string\">&quot;monkey&quot;</span>, <span class=\"hljs-string\">&quot;chimp&quot;</span>, <span class=\"hljs-string\">&quot;donkey&quot;</span>};\n<span class=\"hljs-number\">5</span>: System.out.println(mammals.length);  <span class=\"hljs-comment\">// 3</span>\n<span class=\"hljs-number\">6</span>: System.out.println(mammals[<span class=\"hljs-number\">0</span>]);      <span class=\"hljs-comment\">// monkey</span>\n<span class=\"hljs-number\">7</span>: System.out.println(mammals[<span class=\"hljs-number\">1</span>]);      <span class=\"hljs-comment\">// chimp</span>\n<span class=\"hljs-number\">8</span>: System.out.println(mammals[<span class=\"hljs-number\">2</span>]);      <span class=\"hljs-comment\">// donkey</span>\n</code></pre>","children":[{"content":"Line 4 declares and initializes the array. Line 5 tells us how many<br>\nelements the array can hold. The rest of the code prints the array.<br>\nNotice that elements are indexed starting with <code>0</code>. This should be<br>\nfamiliar from <code>String</code> and <code>StringBuilder</code>, which also start counting<br>\nwith <code>0</code>. Those classes also counted <code>length</code> as the number of<br>\nelements. Note that there are no parentheses after length since it<br>\nis not a method (<strong>in <code>String</code> is method and in array is property</strong>).","children":[{"content":"Watch out for compiler errors like the following on the exam!<pre data-lines=\"155,159\"><code class=\"language-java\"><span class=\"hljs-number\">4</span>: String[] mammals = {<span class=\"hljs-string\">&quot;monkey&quot;</span>, <span class=\"hljs-string\">&quot;chimp&quot;</span>, <span class=\"hljs-string\">&quot;donkey&quot;</span>};\n<span class=\"hljs-number\">5</span>: System.out.println(mammals.length()); <span class=\"hljs-comment\">// DOES NOT COMPILE</span>\n</code></pre>\nTo make sure you understand how <code>length</code> works, what do you think this prints?<pre data-lines=\"160,164\"><code class=\"language-java\"><span class=\"hljs-number\">4</span>: <span class=\"hljs-type\">var</span> <span class=\"hljs-variable\">birds</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">String</span>[<span class=\"hljs-number\">6</span>];\n<span class=\"hljs-number\">5</span>: System.out.println(birds.length);\n</code></pre>\nThe answer is <code>6</code>. Even though all six elements of the array are <code>null</code>, there are<br>\nstill six of them. The <code>length</code> attribute does not consider what is in the array; it<br>\nconsiders only how many slots have been allocated.","children":[{"content":"It is very common to use a loop when reading from or<br>\nwriting to an array. This loop sets each element of<br>\n<code>numbers</code> to five higher than the current index:<pre data-lines=\"170,177\"><code class=\"language-java\"><span class=\"hljs-number\">5</span>: <span class=\"hljs-type\">var</span> <span class=\"hljs-variable\">numbers</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">int</span>[<span class=\"hljs-number\">10</span>];\n<span class=\"hljs-number\">6</span>: <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>; i &lt; numbers.length; i++)\n<span class=\"hljs-number\">7</span>:   numbers[i] = i + <span class=\"hljs-number\">5</span>;\n<span class=\"hljs-number\">8</span>: <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> n : numbers)\n<span class=\"hljs-number\">9</span>:   System.out.println(n);\n</code></pre>","children":[{"content":"Line 5 simply instantiates an array with <code>10</code> slots. Line 6 is a<br>\n<code>for</code> loop that uses an extremely common pattern. It starts at<br>\nindex <code>0</code>, which is where an array begins as well. It keeps<br>\ngoing, one at a time, until it hits the end of the array. Line 7<br>\nsets the current element of <code>numbers</code> to the index of the<br>\nelement plus 5. Lines 8 and 9 print the numbers in the array,<br>\nusing the for-each loop.","children":[{"content":"For our array of size 10, Can you tell why each of these throws an<br>\n<code>ArrayIndexOutOfBoundsException</code>?<pre data-lines=\"186,195\"><code class=\"language-java\"><span class=\"hljs-number\">3</span>: <span class=\"hljs-type\">var</span> <span class=\"hljs-variable\">numbers</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">int</span>[<span class=\"hljs-number\">10</span>];\n<span class=\"hljs-number\">4</span>: numbers[<span class=\"hljs-number\">10</span>] = <span class=\"hljs-number\">3</span>;\n<span class=\"hljs-number\">5</span>:\n<span class=\"hljs-number\">6</span>: numbers[numbers.length] = <span class=\"hljs-number\">5</span>;\n<span class=\"hljs-number\">7</span>:\n<span class=\"hljs-number\">8</span>: <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>; i &lt;= numbers.length; i++)\n<span class=\"hljs-number\">9</span>:   numbers[i] = i + <span class=\"hljs-number\">5</span>;\n</code></pre>","children":[{"content":"The first one is trying to see whether you know that indexes<br>\nstart with <code>0</code>. Since we have 10 elements in our array, this<br>\nmeans only <code>numbers[0]</code> through <code>numbers[9]</code> are valid. The<br>\nsecond example assumes you are clever enough to know<br>\nthat <code>10</code> is invalid and disguises it by using the length field.<br>\nHowever, the <code>length</code> is always one more than the maximum<br>\nvalid index. Finally, the for loop incorrectly uses <code>&lt;=</code> instead<br>\nof <code>&lt;</code>, which is also a way of referring to that tenth index.","children":[],"payload":{"tag":"li","lines":"195,203"}}],"payload":{"tag":"li","lines":"184,203"}}],"payload":{"tag":"li","lines":"177,203"}}],"payload":{"tag":"li","lines":"167,203"}}],"payload":{"tag":"li","lines":"154,203"}}],"payload":{"tag":"li","lines":"147,203"}}],"payload":{"tag":"li","lines":"138,203"}},{"content":"\n<p data-lines=\"203,208\"><strong>Sorting</strong><br>\nJava provides a sort method&#x2014;or rather, a bunch of sort methods.<br>\nYou can pass almost any array to <code>Arrays.sort()</code>.<br>\n<code>Arrays</code> requires an import. To use it, you must have either of the<br>\nfollowing two statements in your class:</p>\n<pre data-lines=\"208,213\"><code class=\"language-java\"><span class=\"hljs-keyword\">import</span> java.util.*; <span class=\"hljs-comment\">// import whole package </span>\n                    <span class=\"hljs-comment\">// including  Arrays</span>\n<span class=\"hljs-keyword\">import</span> java.util.Arrays; <span class=\"hljs-comment\">// import just Arrays</span>\n</code></pre>\n<p data-lines=\"213,216\">There is one exception, although it doesn&#x2019;t come up often on the<br>\nexam. You can write <code>java.util.Arrays</code> every time it is used in the<br>\nclass instead of specifying it as an import.</p>","children":[{"content":"Remember that if you are shown a code snippet, you can<br>\nassume the necessary imports are there. This simple<br>\nexample sorts three numbers:<pre data-lines=\"220,226\"><code class=\"language-java\"><span class=\"hljs-type\">int</span>[] numbers = { <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">9</span>, <span class=\"hljs-number\">1</span> };\nArrays.sort(numbers);\n<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>; i &lt; numbers.length; i++)\n   System.out.print(numbers[i] + <span class=\"hljs-string\">&quot; &quot;</span>);\n</code></pre>","children":[{"content":"The result is <code>1 6 9</code>, as you should expect it to be. Notice that<br>\nwe looped through the output to print the values in the array.<br>\nJust printing the array variable directly would give the annoying<br>\nhash of <code>[I@2bd9c3e7</code>. Alternatively, we could have printed<br>\n<code>Arrays.toString(numbers)</code> instead of using the loop. That<br>\nwould have output <code>[1, 6, 9]</code>.","children":[{"content":"Try this again with <code>String</code> types:<pre data-lines=\"233,239\"><code class=\"language-java\">String[] strings = { <span class=\"hljs-string\">&quot;10&quot;</span>, <span class=\"hljs-string\">&quot;9&quot;</span>, <span class=\"hljs-string\">&quot;100&quot;</span> };\nArrays.sort(strings);\n<span class=\"hljs-keyword\">for</span> (String s : strings)\nSystem.out.print(s + <span class=\"hljs-string\">&quot; &quot;</span>);\n</code></pre>\nThis time the result might not be what you expect. This code<br>\noutputs <code>10 100 9</code>. The problem is that <code>String</code> sorts in alphabetic<br>\norder, and <code>1</code> sorts before <code>9</code>. (Numbers sort before letters, and<br>\nuppercase sorts before lowercase.)","children":[{"content":"You can use <strong>7Up</strong>, the soda, to help remember the order.<br>\nNumbers (7) sort first, followed by uppercase (U), and<br>\nthen lowercase (p).","children":[],"payload":{"tag":"li","lines":"243,246"}}],"payload":{"tag":"li","lines":"232,246"}}],"payload":{"tag":"li","lines":"226,246"}}],"payload":{"tag":"li","lines":"217,246"}}],"payload":{"tag":"li","lines":"203,246"}},{"content":"\n<p data-lines=\"246,250\"><strong>Searching</strong><br>\nJava also provides a convenient way to search, <strong>but only if<br>\nthe array is already sorted.</strong> Table 4.3 covers the rules for<br>\nbinary search.</p>","children":[{"content":"<strong>TABLE 4.3</strong> Binary search rules\n<table data-lines=\"251,256\">\n<thead data-lines=\"251,252\">\n<tr data-lines=\"251,252\">\n<th>Scenario</th>\n<th>Result</th>\n</tr>\n</thead>\n<tbody data-lines=\"253,256\">\n<tr data-lines=\"253,254\">\n<td>Target element<br> found in sorted<br>array</td>\n<td>Index of match</td>\n</tr>\n<tr data-lines=\"254,255\">\n<td>Target element<br>not found in<br>sorted array</td>\n<td>Negative value showing one smaller<br>than the negative of the index, where a<br>match needs to be inserted to preserve<br>sorted order (like <code>~</code> operator)</td>\n</tr>\n<tr data-lines=\"255,256\">\n<td>Unsorted array</td>\n<td>A surprise; this result is undefined</td>\n</tr>\n</tbody>\n</table>","children":[{"content":"\n<p data-lines=\"256,257\">Let&#x2019;s try these rules with an example:</p>\n<pre data-lines=\"258,266\"><code class=\"language-java\"><span class=\"hljs-number\">3</span>: <span class=\"hljs-type\">int</span>[] numbers = {<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">6</span>,<span class=\"hljs-number\">8</span>};\n<span class=\"hljs-number\">4</span>: System.out.println(Arrays.binarySearch(numbers, <span class=\"hljs-number\">2</span>)); <span class=\"hljs-comment\">// 0</span>\n<span class=\"hljs-number\">5</span>: System.out.println(Arrays.binarySearch(numbers, <span class=\"hljs-number\">4</span>)); <span class=\"hljs-comment\">// 1</span>\n<span class=\"hljs-number\">6</span>: System.out.println(Arrays.binarySearch(numbers, <span class=\"hljs-number\">1</span>)); <span class=\"hljs-comment\">// -1</span>\n<span class=\"hljs-number\">7</span>: System.out.println(Arrays.binarySearch(numbers, <span class=\"hljs-number\">3</span>)); <span class=\"hljs-comment\">// -2</span>\n<span class=\"hljs-number\">8</span>: System.out.println(Arrays.binarySearch(numbers, <span class=\"hljs-number\">9</span>)); <span class=\"hljs-comment\">// -5</span>\n</code></pre>\n<p data-lines=\"266,269\">Take note of the fact that line 3 is a sorted array. If it wasn&#x2019;t, we couldn&#x2019;t<br>\napply either of the other rules. Line 4 searches for the index of <code>2</code>. The<br>\nanswer is index <code>0</code>. Line 5 searches for the index of <code>4</code>, which is 1.</p>","children":[{"content":"Line 6 searches for the index of <code>1</code>. Although <code>1</code> isn&#x2019;t in the<br>\nlist, the search can determine that it should be inserted at<br>\nelement 0 to preserve the sorted order. Since 0 already<br>\nmeans something for array indexes, Java needs to subtract<br>\n1 to give us the answer of <code>&#x2013;1</code>. Line 7 is similar. Although <code>3</code><br>\nisn&#x2019;t in the list, it would need to be inserted at element 1 to<br>\npreserve the sorted order. We negate and subtract 1 for<br>\nconsistency, getting <code>&#x2013;1&#x2013;1</code>, also known as <code>&#x2013;2</code>. Finally, line 8<br>\nwants to tell us that 9 should be inserted at index <code>4</code>. We<br>\nagain negate and subtract 1, getting <code>&#x2013;4&#x2013;1</code>, also known as <code>&#x2013;5</code>.","children":[{"content":"What do you think happens in this example?<pre data-lines=\"280,285\"><code class=\"language-java\"><span class=\"hljs-number\">5</span>: <span class=\"hljs-type\">int</span>[] numbers = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">int</span>[] {<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">1</span>};\n<span class=\"hljs-number\">6</span>: System.out.println(Arrays.binarySearch(numbers, <span class=\"hljs-number\">2</span>));\n<span class=\"hljs-number\">7</span>: System.out.println(Arrays.binarySearch(numbers, <span class=\"hljs-number\">3</span>));\n</code></pre>\nNote that on line 5, the array isn&#x2019;t sorted. As soon as you see the<br>\narray isn&#x2019;t sorted, look for an answer choice about unpredictable<br>\noutput.<br>\nOn the exam, you need to know what a binary search returns in<br>\nvarious scenarios.","children":[],"payload":{"tag":"li","lines":"279,290"}}],"payload":{"tag":"li","lines":"269,290"}}],"payload":{"tag":"li","lines":"256,290"}}],"payload":{"tag":"li","lines":"250,290"}}],"payload":{"tag":"li","lines":"246,290"}}],"payload":{"tag":"h1","lines":"5,6"}},{"initialExpandLevel":1})</script>
</body>
</html>
