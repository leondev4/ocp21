<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<title>Markmap</title>
<style>
* {
  margin: 0;
  padding: 0;
}
#mindmap {
  display: block;
  width: 100vw;
  height: 100vh;
}
</style>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@highlightjs/cdn-assets@11.11.1/styles/default.min.css">
</head>
<body>
<svg id="mindmap"></svg>
<script src="https://cdn.jsdelivr.net/npm/d3@7.9.0/dist/d3.min.js"></script><script src="https://cdn.jsdelivr.net/npm/markmap-view@0.18.10/dist/browser/index.js"></script><script src="https://cdn.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/index.js"></script><script>(r => {
              setTimeout(r);
            })(function renderToolbar() {
  const {
    markmap,
    mm
  } = window;
  const {
    el
  } = markmap.Toolbar.create(mm);
  el.setAttribute('style', 'position:absolute;bottom:20px;right:20px');
  document.body.append(el);
})</script><script>((getMarkmap, getOptions, root2, jsonOptions) => {
              const markmap = getMarkmap();
              window.mm = markmap.Markmap.create(
                "svg#mindmap",
                (getOptions || markmap.deriveOptions)(jsonOptions),
                root2
              );
            })(() => window.markmap,null,{"content":"<strong>Using the StringBuilder Class</strong>","children":[{"content":"\n<p data-lines=\"6,8\">The <code>StringBuilder</code> class creates a <code>String</code> without storing interim<br>\nvalues. Unlike the <code>String</code> class, <code>StringBuilder</code> is mutable.</p>","children":[],"payload":{"tag":"li","lines":"6,9"}},{"content":"\n<p data-lines=\"9,16\"><strong>Mutability and Chaining</strong><br>\nThe exam will likely try to trick you with respect to <code>StringBuilder</code> being<br>\nmutable and <code>String</code> being immutable.<br>\nChaining makes this even more interesting. When we chained <code>String</code><br>\nmethod calls, the result was a new <code>String</code> with the answer. Chaining<br>\n<code>StringBuilder</code> methods doesn&#x2019;t work this way. Instead, the <code>StringBuilder</code><br>\nchanges its own state and returns a reference to itself.</p>","children":[{"content":"Let&#x2019;s look at an example to make this clearer:<pre data-lines=\"17,22\"><code class=\"language-java\"><span class=\"hljs-number\">4</span>: <span class=\"hljs-type\">StringBuilder</span> <span class=\"hljs-variable\">sb</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">StringBuilder</span>(<span class=\"hljs-string\">&quot;start&quot;</span>);\n<span class=\"hljs-number\">5</span>: sb.append(<span class=\"hljs-string\">&quot;+middle&quot;</span>); <span class=\"hljs-comment\">// sb = &quot;start+middle&quot;</span>\n<span class=\"hljs-number\">6</span>: <span class=\"hljs-type\">StringBuilder</span> <span class=\"hljs-variable\">same</span> <span class=\"hljs-operator\">=</span> sb.append(<span class=\"hljs-string\">&quot;+end&quot;</span>); <span class=\"hljs-comment\">// &quot;start+middle+end&quot;</span>\n</code></pre>","children":[{"content":"Line 5 adds text to the end of <code>sb</code>. It also returns a reference<br>\nto <code>sb</code>, which is ignored. Line 6 also adds text to the end of <code>sb</code><br>\nand returns a reference to <code>sb</code>. This time the reference is<br>\nstored in <code>same</code>. This means <code>sb</code> and <code>same</code> point to the same<br>\nobject and would print out the same value.","children":[{"content":"The exam won&#x2019;t always make the code easy to read by<br>\nhaving only one method per line. What do you think this<br>\nexample prints?<pre data-lines=\"30,37\"><code class=\"language-java\"><span class=\"hljs-number\">4</span>: <span class=\"hljs-type\">StringBuilder</span> <span class=\"hljs-variable\">a</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">StringBuilder</span>(<span class=\"hljs-string\">&quot;abc&quot;</span>);\n<span class=\"hljs-number\">5</span>: <span class=\"hljs-type\">StringBuilder</span> <span class=\"hljs-variable\">b</span> <span class=\"hljs-operator\">=</span> a.append(<span class=\"hljs-string\">&quot;de&quot;</span>);\n<span class=\"hljs-number\">6</span>: b = b.append(<span class=\"hljs-string\">&quot;f&quot;</span>).append(<span class=\"hljs-string\">&quot;g&quot;</span>);\n<span class=\"hljs-number\">7</span>: System.out.println(<span class=\"hljs-string\">&quot;a=&quot;</span> + a);\n<span class=\"hljs-number\">8</span>: System.out.println(<span class=\"hljs-string\">&quot;b=&quot;</span> + b);\n</code></pre>","children":[{"content":"There&#x2019;s only one <code>StringBuilder</code> object here. We know that<br>\nbecause <code>new StringBuilder()</code> is called only once. On line 5,<br>\nthere are two variables referring to that object which has a<br>\nvalue of <code>&quot;abcde&quot;</code>. On line 6, those two variables are still<br>\nreferring to that same object, which now has a value<br>\nof <code>&quot;abcdefg&quot;</code>. Incidentally, the assignment back to <code>b</code> does<br>\nabsolutely nothing. <code>b</code> is already pointing to that <code>StringBuilder</code>.","children":[{"content":"\n<p data-lines=\"44,46\"><strong>Creating a StringBuilder</strong><br>\nThere are three ways to construct a <code>StringBuilder</code>:</p>\n<pre data-lines=\"46,51\"><code class=\"language-java\"><span class=\"hljs-type\">StringBuilder</span> <span class=\"hljs-variable\">sb1</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">StringBuilder</span>();\n<span class=\"hljs-type\">StringBuilder</span> <span class=\"hljs-variable\">sb2</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">StringBuilder</span>(<span class=\"hljs-string\">&quot;animal&quot;</span>);\n<span class=\"hljs-type\">StringBuilder</span> <span class=\"hljs-variable\">sb3</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">StringBuilder</span>(<span class=\"hljs-number\">10</span>);\n</code></pre>","children":[{"content":"The first says to create a <code>StringBuilder</code> containing an empty<br>\nsequence of characters and assign <code>sb1</code> to point to it. The<br>\nsecond says to create a <code>StringBuilder</code> containing a specific<br>\nvalue and assign <code>sb2</code> to point to it. The first two examples tell<br>\nJava to manage the implementation details. The final<br>\nexample tells Java that we have some idea of how big the<br>\neventual value will be and would like the <code>StringBuilder</code> to<br>\nreserve a certain capacity, or number of slots, for characters.","children":[],"payload":{"tag":"li","lines":"52,60"}}],"payload":{"tag":"li","lines":"44,60"}}],"payload":{"tag":"li","lines":"37,60"}}],"payload":{"tag":"li","lines":"27,60"}}],"payload":{"tag":"li","lines":"22,60"}}],"payload":{"tag":"li","lines":"16,60"}}],"payload":{"tag":"li","lines":"9,60"}},{"content":"\n<p data-lines=\"60,62\"><strong>Important <code>StringBuilder</code> Methods</strong><br>\nThese are the ones you might see on the exam.</p>","children":[{"content":"<strong>Using Common Methods</strong><br>\nThese four methods work exactly the same as in the <code>String</code> class.<pre data-lines=\"64,71\"><code class=\"language-java\"><span class=\"hljs-type\">var</span> <span class=\"hljs-variable\">sb</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">StringBuilder</span>(<span class=\"hljs-string\">&quot;animals&quot;</span>);\n<span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">sub</span> <span class=\"hljs-operator\">=</span> sb.substring(sb.indexOf(<span class=\"hljs-string\">&quot;a&quot;</span>), sb.indexOf(<span class=\"hljs-string\">&quot;al&quot;</span>));\n<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">len</span> <span class=\"hljs-operator\">=</span> sb.length();\n<span class=\"hljs-type\">char</span> <span class=\"hljs-variable\">ch</span> <span class=\"hljs-operator\">=</span> sb.charAt(<span class=\"hljs-number\">6</span>);\nSystem.out.println(sub + <span class=\"hljs-string\">&quot; &quot;</span> + len + <span class=\"hljs-string\">&quot; &quot;</span> + ch); <span class=\"hljs-comment\">// anim 7 s</span>\n</code></pre>","children":[{"content":"The <code>indexOf()</code> method calls return <code>0</code> and <code>4</code>, respectively.<br>\nThe <code>substring()</code> method returns the <code>String</code> starting with<br>\nindex <code>0</code> and ending right before index <code>4</code>.<br>\nThe <code>length()</code> method returns <code>7</code> because it is the number of<br>\ncharacters in the <code>StringBuilder</code> rather than an index. Finally,<br>\n<code>charAt()</code> returns the character at index <code>6</code>. Here, we do start<br>\nwith <code>0</code> because we are referring to indexes.<br>\nNotice that <code>substring()</code> returns a <code>String</code> rather than a<br>\n<code>StringBuilder</code>. That is why <code>sb</code> is not changed","children":[{"content":"<strong>Appending Values</strong><br>\nThe <code>append()</code> method is by far the most frequently used<br>\nmethod in <code>StringBuilder</code>. It adds the parameter to the<br>\n<code>StringBuilder</code> and returns a reference to the current<br>\n<code>StringBuilder</code>. One of the method signatures is as follows:<pre data-lines=\"85,88\"><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> StringBuilder <span class=\"hljs-title function_\">append</span><span class=\"hljs-params\">(String str)</span>\n</code></pre>\nThere are more than 10 method signatures that look similar but<br>\ntake different data types as parameters, such as <code>int</code>, <code>char</code>, etc.","children":[{"content":"you can write code like this:<pre data-lines=\"91,96\"><code class=\"language-java\"><span class=\"hljs-type\">var</span> <span class=\"hljs-variable\">sb</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">StringBuilder</span>().append(<span class=\"hljs-number\">1</span>).append(<span class=\"hljs-string\">&apos;c&apos;</span>);\nsb.append(<span class=\"hljs-string\">&quot;-&quot;</span>).append(<span class=\"hljs-literal\">true</span>);\nSystem.out.println(sb); <span class=\"hljs-comment\">// 1c-true</span>\n</code></pre>\nThe <code>append()</code> method is called directly after the constructor.<br>\nBy having all these method signatures, you can just call <code>append()</code><br>\nwithout having to convert your parameter to a <code>String</code> first.","children":[{"content":"<strong>Applying Code Points</strong><br>\nThe <code>codePointAt()</code>, <code>codePointBefore()</code>, and <code>codePointCount()</code><br>\nmethods from <code>String</code> are also available on <code>StringBuilder</code>.<br>\nThere&#x2019;s one more method you need to know for code points<br>\nthat is only on <code>StringBuilder</code>:<pre data-lines=\"104,107\"><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> StringBuilder <span class=\"hljs-title function_\">appendCodePoint</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> codePoint)</span>\n</code></pre>","children":[{"content":"It works like the <code>append()</code> method in the previous section<br>\nexcept <b>it takes an integer representing the Unicode value,<br>\nconverts it to a character, and appends</b> it to the <code>StringBuilder</code>.<pre data-lines=\"110,118\"><code class=\"language-java\"><span class=\"hljs-type\">var</span> <span class=\"hljs-variable\">sb</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">StringBuilder</span>()\n    .appendCodePoint(<span class=\"hljs-number\">87</span>).append(<span class=\"hljs-string\">&apos;,&apos;</span>)\n    .append((<span class=\"hljs-type\">char</span>)<span class=\"hljs-number\">87</span>).append(<span class=\"hljs-string\">&apos;,&apos;</span>)\n    .append(<span class=\"hljs-number\">87</span>).append(<span class=\"hljs-string\">&apos;,&apos;</span>)\n    .appendCodePoint(<span class=\"hljs-number\">8217</span>);\nSystem.out.println(sb); <span class=\"hljs-comment\">// W,W,87,&#xe2;&#x20ac;&#x2122;</span>\n</code></pre>","children":[],"payload":{"tag":"li","lines":"107,118"}}],"payload":{"tag":"li","lines":"99,118"}}],"payload":{"tag":"li","lines":"90,118"}}],"payload":{"tag":"li","lines":"80,118"}}],"payload":{"tag":"li","lines":"71,118"}}],"payload":{"tag":"li","lines":"62,118"}}],"payload":{"tag":"li","lines":"60,118"}},{"content":"\n<p data-lines=\"118,123\"><strong>Inserting Data</strong><br>\nThe <code>insert()</code> method adds characters to the <code>StringBuilder</code> at<br>\nthe requested index and returns a reference to the current<br>\n<code>StringBuilder</code>. There are lots of method signatures for different<br>\ntypes. Here&#x2019;s one:</p>\n<pre data-lines=\"123,126\"><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> StringBuilder <span class=\"hljs-title function_\">insert</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> offset, String str)</span>\n</code></pre>","children":[{"content":"Pay attention to the offset in these examples. It is the index<br>\nwhere we want to insert the requested parameter.<pre data-lines=\"128,135\"><code class=\"language-java\"><span class=\"hljs-number\">3</span>: <span class=\"hljs-type\">var</span> <span class=\"hljs-variable\">sb</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">StringBuilder</span>(<span class=\"hljs-string\">&quot;animals&quot;</span>);\n<span class=\"hljs-number\">4</span>: sb.insert(<span class=\"hljs-number\">7</span>, <span class=\"hljs-string\">&quot;-&quot;</span>); <span class=\"hljs-comment\">// sb = animals-</span>\n<span class=\"hljs-number\">5</span>: sb.insert(<span class=\"hljs-number\">0</span>, <span class=\"hljs-string\">&quot;-&quot;</span>); <span class=\"hljs-comment\">// sb = -animals-</span>\n<span class=\"hljs-number\">6</span>: sb.insert(<span class=\"hljs-number\">4</span>, <span class=\"hljs-string\">&quot;-&quot;</span>); <span class=\"hljs-comment\">// sb = -ani-mals-</span>\n<span class=\"hljs-number\">7</span>: System.out.println(sb);\n</code></pre>","children":[{"content":"Line 4 says to insert a dash at index <code>7</code>, which happens to be<br>\nthe end of the sequence of characters. Line 5 says to insert<br>\na dash at index <code>0</code>, which happens to be the very beginning.<br>\nFinally, line 6 says to insert a dash right before index <code>4</code>. The<br>\nexam creators will try to trip you up on this. As we add and<br>\nremove characters, their indexes change. When you see a<br>\nquestion dealing with such operations, draw what is going<br>\non using available writing materials so you won&#x2019;t be<br>\nconfused.","children":[{"content":"<strong>Deleting Contents</strong><br>\nThe <code>delete()</code> method is the opposite of the <code>insert()</code> method. It removes<br>\ncharacters from the sequence and returns a reference to the current<br>\n<code>StringBuilder</code>. The <code>deleteCharAt()</code> method is convenient when you want<br>\nto delete only one character. The method signatures are as follows:<pre data-lines=\"149,153\"><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> StringBuilder <span class=\"hljs-title function_\">delete</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> startIndex, <span class=\"hljs-type\">int</span> endIndex)</span>\n<span class=\"hljs-keyword\">public</span> StringBuilder <span class=\"hljs-title function_\">deleteCharAt</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> index)</span>\n</code></pre>","children":[{"content":"\n<p data-lines=\"153,154\">The following code shows how to use these methods:</p>\n<pre data-lines=\"154,159\"><code class=\"language-java\"><span class=\"hljs-type\">var</span> <span class=\"hljs-variable\">sb</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">StringBuilder</span>(<span class=\"hljs-string\">&quot;abcdef&quot;</span>);\nsb.delete(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">3</span>);    <span class=\"hljs-comment\">// sb = adef</span>\nsb.deleteCharAt(<span class=\"hljs-number\">5</span>); <span class=\"hljs-comment\">// exception</span>\n</code></pre>\n<p data-lines=\"159,164\">First, we delete the characters starting with index <code>1</code> and<br>\nending right before index <code>3</code>. This gives us <code>adef</code>. Next, we ask<br>\nJava to delete the character at position <code>5</code>. However, the<br>\nremaining value is only four characters long, so it throws a<br>\n<code>StringIndexOutOfBoundsException</code>.</p>","children":[{"content":"The <code>delete()</code> method is more flexible than some others when<br>\nit comes to array indexes. If you specify a second parameter<br>\nthat is past the end of the <code>StringBuilder</code>, Java will just assume<br>\nyou meant the end. That means this code is legal:<pre data-lines=\"169,173\"><code class=\"language-java\"><span class=\"hljs-type\">var</span> <span class=\"hljs-variable\">sb</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">StringBuilder</span>(<span class=\"hljs-string\">&quot;abcdef&quot;</span>);\nsb.delete(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">100</span>); <span class=\"hljs-comment\">// sb = a</span>\n</code></pre>","children":[{"content":"<strong>Reversing</strong><br>\nThe <code>reverse()</code> method reverses the characters in the<br>\nsequences and returns a reference to the current<br>\n<code>StringBuilder</code>. The method signature is as follows:<pre data-lines=\"177,180\"><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> StringBuilder <span class=\"hljs-title function_\">reverse</span><span class=\"hljs-params\">()</span>\n</code></pre>\nThe following code shows how to use this method:<pre data-lines=\"181,186\"><code class=\"language-java\"><span class=\"hljs-type\">var</span> <span class=\"hljs-variable\">sb</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">StringBuilder</span>(<span class=\"hljs-string\">&quot;ABC&quot;</span>);\nsb.reverse();\nSystem.out.println(sb); <span class=\"hljs-comment\">// CBA</span>\n</code></pre>","children":[],"payload":{"tag":"li","lines":"173,186"}}],"payload":{"tag":"li","lines":"165,186"}}],"payload":{"tag":"li","lines":"153,186"}}],"payload":{"tag":"li","lines":"144,186"}}],"payload":{"tag":"li","lines":"135,186"}}],"payload":{"tag":"li","lines":"126,186"}}],"payload":{"tag":"li","lines":"118,186"}},{"content":"\n<p data-lines=\"186,189\"><strong>Replacing Portions</strong><br>\nThe <code>replace()</code> method works differently for <code>StringBuilder</code><br>\nthan it did for <code>String</code>. The method signature is as follows:</p>\n<pre data-lines=\"189,192\"><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> StringBuilder <span class=\"hljs-title function_\">replace</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> startIdx, <span class=\"hljs-type\">int</span> endIdx, String newStr)</span>\n</code></pre>","children":[{"content":"\n<p data-lines=\"192,193\">The following code shows how to use this method:</p>\n<pre data-lines=\"193,198\"><code class=\"language-java\"><span class=\"hljs-type\">var</span> <span class=\"hljs-variable\">builder</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">StringBuilder</span>(<span class=\"hljs-string\">&quot;pigeon dirty&quot;</span>);\nbuilder.replace(<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-string\">&quot;sty&quot;</span>);\nSystem.out.println(builder); <span class=\"hljs-comment\">// pigsty dirty</span>\n</code></pre>\n<p data-lines=\"198,201\">First, Java deletes the characters starting with index <code>3</code> and<br>\nending right before index <code>6</code>. This gives us <code>pig dirty</code>. Then<br>\nJava inserts the value <code>sty</code> in that position.</p>","children":[{"content":"In this example, the number of characters removed and<br>\ninserted are the same. What do you think this does?<pre data-lines=\"204,209\"><code class=\"language-java\"><span class=\"hljs-type\">var</span> <span class=\"hljs-variable\">builder</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">StringBuilder</span>(<span class=\"hljs-string\">&quot;pigeon dirty&quot;</span>);\nbuilder.replace(<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">100</span>, <span class=\"hljs-string\">&quot;&quot;</span>);\nSystem.out.println(builder);\n</code></pre>\nIt prints <code>pig</code>. Remember, the method is first doing a logical<br>\ndelete. The <code>replace()</code> method <strong>allows specifying a second<br>\nparameter that is past the end of the <code>StringBuilder</code></strong>.<br>\nThat means only the first three characters remain.","children":[],"payload":{"tag":"li","lines":"202,213"}}],"payload":{"tag":"li","lines":"192,213"}}],"payload":{"tag":"li","lines":"186,213"}}],"payload":{"tag":"h1","lines":"5,6"}},{"initialExpandLevel":1})</script>
</body>
</html>
