<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<title>Markmap</title>
<style>
* {
  margin: 0;
  padding: 0;
}
#mindmap {
  display: block;
  width: 100vw;
  height: 100vh;
}
</style>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@highlightjs/cdn-assets@11.11.1/styles/default.min.css">
</head>
<body>
<svg id="mindmap"></svg>
<script src="https://cdn.jsdelivr.net/npm/d3@7.9.0/dist/d3.min.js"></script><script src="https://cdn.jsdelivr.net/npm/markmap-view@0.18.10/dist/browser/index.js"></script><script src="https://cdn.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/index.js"></script><script>(r => {
              setTimeout(r);
            })(function renderToolbar() {
  const {
    markmap,
    mm
  } = window;
  const {
    el
  } = markmap.Toolbar.create(mm);
  el.setAttribute('style', 'position:absolute;bottom:20px;right:20px');
  document.body.append(el);
})</script><script>((getMarkmap, getOptions, root2, jsonOptions) => {
              const markmap = getMarkmap();
              window.mm = markmap.Markmap.create(
                "svg#mindmap",
                (getOptions || markmap.deriveOptions)(jsonOptions),
                root2
              );
            })(() => window.markmap,null,{"content":"<strong>Understanding Equality</strong>","children":[{"content":"<strong>Comparing <code>equals()</code> and <code>==</code></strong><br>\nConsider the following code that uses <code>==</code> with objects:<pre data-lines=\"8,15\"><code class=\"language-java\"><span class=\"hljs-type\">var</span> <span class=\"hljs-variable\">one</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">StringBuilder</span>();\n<span class=\"hljs-type\">var</span> <span class=\"hljs-variable\">two</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">StringBuilder</span>();\n<span class=\"hljs-type\">var</span> <span class=\"hljs-variable\">three</span> <span class=\"hljs-operator\">=</span> one.append(<span class=\"hljs-string\">&quot;a&quot;</span>);\nSystem.out.println(one == two); <span class=\"hljs-comment\">// false</span>\nSystem.out.println(one == three); <span class=\"hljs-comment\">// true</span>\n</code></pre>","children":[{"content":"Since this example isn&#x2019;t dealing with primitives, we know to<br>\nlook for whether the references are referring to the same<br>\nobject. The <code>one</code> and <code>two</code> variables are both completely<br>\nseparate <code>StringBuilder</code> objects, giving us two objects.<br>\nTherefore, the first print statement gives us <code>false</code>. The <code>three</code><br>\nvariable is more interesting. Remember how <code>StringBuilder</code><br>\nmethods like to return the current reference for chaining?<br>\nThis means <code>one</code> and <code>three</code> both point to the same object, and<br>\nthe second print statement gives us <code>true</code>.","children":[{"content":"<code>equals()</code> uses logical equality rather than object equality<br>\nfor <code>String</code> objects.<pre data-lines=\"26,31\"><code class=\"language-java\"><span class=\"hljs-type\">var</span> <span class=\"hljs-variable\">x</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;Hello World&quot;</span>;\n<span class=\"hljs-type\">var</span> <span class=\"hljs-variable\">z</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot; Hello World&quot;</span>.trim();\nSystem.out.println(x.equals(z)); <span class=\"hljs-comment\">// true</span>\n</code></pre>\n<code>String</code> class implements a standard method called <code>equals()</code><br>\nto check the values inside the <code>String</code> rather than the string<br>\nreference itself. If a class doesn&#x2019;t have an <code>equals()</code> method,<br>\nJava determines whether the references point to the same<br>\nobject, which is exactly what <code>==</code> does.","children":[{"content":"<code>StringBuilder</code> does not implement <code>equals()</code>. If you call <code>equals()</code><br>\non two <code>StringBuilder</code> instances, it will check reference equality.<br>\nYou can call <code>toString()</code> on <code>StringBuilder</code> to get a <code>String</code> to check<br>\nfor equality instead.","children":[{"content":"Can you guess why the code doesn&#x2019;t compile?<pre data-lines=\"41,46\"><code class=\"language-java\"><span class=\"hljs-type\">var</span> <span class=\"hljs-variable\">name</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;a&quot;</span>;\n<span class=\"hljs-type\">var</span> <span class=\"hljs-variable\">builder</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">StringBuilder</span>(<span class=\"hljs-string\">&quot;a&quot;</span>);\nSystem.out.println(name == builder); <span class=\"hljs-comment\">// DOES NOT COMPILE</span>\n</code></pre>\nRemember that <code>==</code> is checking for object reference equality. The<br>\ncompiler is smart enough to know that two references can&#x2019;t possibly<br>\npoint to the same object when they are completely different types.","children":[],"payload":{"tag":"li","lines":"40,49"}}],"payload":{"tag":"li","lines":"36,49"}}],"payload":{"tag":"li","lines":"24,49"}}],"payload":{"tag":"li","lines":"15,49"}}],"payload":{"tag":"li","lines":"6,49"}},{"content":"<strong>The String Pool</strong><br>\nThe string pool contains literal values and constants that<br>\nappear in your program. For example, <code>&quot;name&quot;</code> is a literal and<br>\ntherefore goes into the string pool. The <code>myObject.toString()</code><br>\nmethod returns a string but not a literal, so it does not go<br>\ninto the string pool.","children":[{"content":"The JVM reuses <code>String</code> literals.<pre data-lines=\"56,61\"><code class=\"language-java\"><span class=\"hljs-type\">var</span> <span class=\"hljs-variable\">x</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;Hello World&quot;</span>;\n<span class=\"hljs-type\">var</span> <span class=\"hljs-variable\">y</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;Hello World&quot;</span>;\nSystem.out.println(x == y); <span class=\"hljs-comment\">// true</span>\n</code></pre>\nRemember that a <code>String</code> is immutable and literals are<br>\npooled. The JVM created only one literal in memory. The <code>x</code><br>\nand <code>y</code> variables both point to the same location in memory;<br>\ntherefore, the statement outputs <code>true</code>.","children":[{"content":"Consider this code:<pre data-lines=\"66,71\"><code class=\"language-java\"><span class=\"hljs-type\">var</span> <span class=\"hljs-variable\">x</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;Hello World&quot;</span>;\n<span class=\"hljs-type\">var</span> <span class=\"hljs-variable\">z</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot; Hello World&quot;</span>.trim();\nSystem.out.println(x == z); <span class=\"hljs-comment\">// false</span>\n</code></pre>\nIn this example, we don&#x2019;t have two of the same <code>String</code> literal.<br>\nAlthough <code>x</code> and <code>z</code> happen to evaluate to the same string,<br>\n<strong>one is computed at runtime. Since it isn&#x2019;t the same at<br>\ncompile time, a new <code>String</code> object is created.</strong>","children":[{"content":"Let&#x2019;s try another one. What do you think is output here?<pre data-lines=\"76,82\"><code class=\"language-java\"><span class=\"hljs-type\">var</span> <span class=\"hljs-variable\">singleString</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;hello world&quot;</span>;\n<span class=\"hljs-type\">var</span> <span class=\"hljs-variable\">concat</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;hello &quot;</span>;\nconcat += <span class=\"hljs-string\">&quot;world&quot;</span>;\nSystem.out.println(singleString == concat); <span class=\"hljs-comment\">// false</span>\n</code></pre>\nThis prints <code>false</code>. <strong>Calling <code>+=</code> is just like calling a method and<br>\nresults in a new <code>String</code>.</strong>","children":[{"content":"Other example:<pre data-lines=\"85,90\"><code class=\"language-java\"><span class=\"hljs-type\">var</span> <span class=\"hljs-variable\">x</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;Hello World&quot;</span>;\n<span class=\"hljs-type\">var</span> <span class=\"hljs-variable\">y</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">String</span>(<span class=\"hljs-string\">&quot;Hello World&quot;</span>);\nSystem.out.println(x == y); <span class=\"hljs-comment\">// false</span>\n</code></pre>\nThe first says to use the string pool normally. The second<br>\nsays, &#x201c;No, JVM, I really don&#x2019;t want you to use the string<br>\npool. Please create a new object for me even though it is<br>\nless efficient.&#x201d;","children":[{"content":"The <code>intern()</code> method will use an object in the string pool<br>\nif one is present.<pre data-lines=\"96,99\"><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title function_\">intern</span><span class=\"hljs-params\">()</span>\n</code></pre>\nIf the literal is not yet in the string pool, Java will add it at<br>\nthis time.<pre data-lines=\"101,106\"><code class=\"language-java\"><span class=\"hljs-type\">var</span> <span class=\"hljs-variable\">name</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;Hello World&quot;</span>;\n<span class=\"hljs-type\">var</span> <span class=\"hljs-variable\">name2</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">String</span>(<span class=\"hljs-string\">&quot;Hello World&quot;</span>).intern();\nSystem.out.println(name == name2); <span class=\"hljs-comment\">// true</span>\n</code></pre>","children":[{"content":"First we tell Java to use the string pool normally for <code>name</code>.<br>\nThen, for <code>name2</code>, we tell Java to create a new object using the<br>\nconstructor but to intern it and use the string pool anyway.<br>\nSince both variables point to the same reference in the string<br>\npool, we can use the <code>==</code> operator.","children":[{"content":"Let&#x2019;s try another one. What do you think this prints out? Be<br>\ncareful. It is tricky.<pre data-lines=\"113,122\"><code class=\"language-java\"><span class=\"hljs-number\">15</span>: <span class=\"hljs-type\">var</span> <span class=\"hljs-variable\">first</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;rat&quot;</span> + <span class=\"hljs-number\">1</span>;\n<span class=\"hljs-number\">16</span>: <span class=\"hljs-type\">var</span> <span class=\"hljs-variable\">second</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;r&quot;</span> + <span class=\"hljs-string\">&quot;a&quot;</span> + <span class=\"hljs-string\">&quot;t&quot;</span> + <span class=\"hljs-string\">&quot;1&quot;</span>;\n<span class=\"hljs-number\">17</span>: <span class=\"hljs-type\">var</span> <span class=\"hljs-variable\">third</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;r&quot;</span> + <span class=\"hljs-string\">&quot;a&quot;</span> + <span class=\"hljs-string\">&quot;t&quot;</span> + <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">String</span>(<span class=\"hljs-string\">&quot;1&quot;</span>);\n<span class=\"hljs-number\">18</span>: System.out.println(first == second);\n<span class=\"hljs-number\">19</span>: System.out.println(first == second.intern());\n<span class=\"hljs-number\">20</span>: System.out.println(first == third);\n<span class=\"hljs-number\">21</span>: System.out.println(first == third.intern());\n</code></pre>","children":[{"content":"On line 15, we have a compile-time constant that<br>\nautomatically gets placed in the string pool as <code>&quot;rat1&quot;</code>. On<br>\nline 16, we have a more complicated expression that is also<br>\na compile-time constant. Therefore, <strong><code>first</code> and <code>second</code> share<br>\nthe same string pool reference.</strong> This makes lines 18 and 19<br>\nprint <code>true</code>.","children":[],"payload":{"tag":"li","lines":"122,128"}},{"content":"On line 17, we have a <code>String</code> constructor. This means we no<br>\nlonger have a compile-time constant, and <code>third</code> does not<br>\npoint to a reference in the string pool. Therefore, line 20<br>\nprints <code>false</code>. On line 21, the <code>intern()</code> call looks in the string<br>\npool. Java notices that <code>first</code> points to the same <code>String</code> and<br>\nprints <code>true</code>.","children":[{"content":"Other example:<pre data-lines=\"135,143\"><code class=\"language-java\"><span class=\"hljs-type\">var</span> <span class=\"hljs-variable\">r1</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;rat&quot;</span> + <span class=\"hljs-number\">1</span>;\n<span class=\"hljs-type\">var</span> <span class=\"hljs-variable\">r2</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;rat&quot;</span>;\nr2 += <span class=\"hljs-number\">1</span>;\n<span class=\"hljs-type\">var</span> <span class=\"hljs-variable\">r3</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;rat1&quot;</span>;\nSystem.out.println(r1 == r2);<span class=\"hljs-comment\">//false</span>\nSystem.out.println(r1 == r3);<span class=\"hljs-comment\">//true</span>\n</code></pre>","children":[],"payload":{"tag":"li","lines":"134,143"}}],"payload":{"tag":"li","lines":"128,143"}}],"payload":{"tag":"li","lines":"111,143"}}],"payload":{"tag":"li","lines":"106,143"}}],"payload":{"tag":"li","lines":"94,143"}}],"payload":{"tag":"li","lines":"84,143"}}],"payload":{"tag":"li","lines":"75,143"}}],"payload":{"tag":"li","lines":"65,143"}}],"payload":{"tag":"li","lines":"55,143"}}],"payload":{"tag":"li","lines":"49,143"}}],"payload":{"tag":"h1","lines":"5,6"}},{"initialExpandLevel":1})</script>
</body>
</html>
