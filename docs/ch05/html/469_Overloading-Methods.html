<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<title>Markmap</title>
<style>
* {
  margin: 0;
  padding: 0;
}
#mindmap {
  display: block;
  width: 100vw;
  height: 100vh;
}
</style>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@highlightjs/cdn-assets@11.11.1/styles/default.min.css">
</head>
<body>
<svg id="mindmap"></svg>
<script src="https://cdn.jsdelivr.net/npm/d3@7.9.0/dist/d3.min.js"></script><script src="https://cdn.jsdelivr.net/npm/markmap-view@0.18.10/dist/browser/index.js"></script><script src="https://cdn.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/index.js"></script><script>(r => {
              setTimeout(r);
            })(function renderToolbar() {
  const {
    markmap,
    mm
  } = window;
  const {
    el
  } = markmap.Toolbar.create(mm);
  el.setAttribute('style', 'position:absolute;bottom:20px;right:20px');
  document.body.append(el);
})</script><script>((getMarkmap, getOptions, root2, jsonOptions) => {
              const markmap = getMarkmap();
              window.mm = markmap.Markmap.create(
                "svg#mindmap",
                (getOptions || markmap.deriveOptions)(jsonOptions),
                root2
              );
            })(() => window.markmap,null,{"content":"<strong>Overloading Methods</strong>","children":[{"content":"<em>Method overloading</em> occurs when methods in the same class<br>\nhave the same name but different method signatures, which<br>\nmeans they use different parameter lists. We can change<br>\nthe type of parameters and the number of parameters.<br>\nEverything other than the method name can vary for<br>\noverloading methods. This means there can be different<br>\naccess modifiers, optional specifiers (like <code>static</code>), return<br>\ntypes, and exception lists.","children":[{"content":"The following shows five overloaded versions of the <code>fly()</code> method:<pre data-lines=\"15,24\"><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Falcon</span> {\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">fly</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> numMiles)</span> <span class=\"hljs-keyword\">throws</span> Exception {}\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">fly</span><span class=\"hljs-params\">(<span class=\"hljs-type\">short</span> numFeet)</span> {}\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">boolean</span> <span class=\"hljs-title function_\">fly</span><span class=\"hljs-params\">()</span> { <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>; }\n  <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">fly</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> numMiles, <span class=\"hljs-type\">short</span> numFeet)</span> {}\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">fly</span><span class=\"hljs-params\">(<span class=\"hljs-type\">short</span> numFeet, <span class=\"hljs-type\">int</span> numMiles)</span>  {}\n}\n</code></pre>","children":[{"content":"As you can see, we can overload by changing anything in<br>\nthe parameter list. We can have a different type, more<br>\ntypes, or the same types in a different order. Also notice<br>\nthat the return type, access modifier, and exception list are<br>\nirrelevant to overloading. <strong>Only the method name and<br>\nparameter list matter.</strong>","children":[{"content":"Now let&#x2019;s look at an example that is not valid overloading:<pre data-lines=\"31,38\"><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Eagle</span> {\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">fly</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> numMiles)</span> {}\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">fly</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> numMiles)</span> { <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>; } <span class=\"hljs-comment\">// DOES NOT COMPILE</span>\n}\n\n</code></pre>\nThis method doesn&#x2019;t compile because it differs from the original only by return<br>\ntype. The method signatures are the same, so they are duplicate methods as<br>\nfar as Java is concerned.","children":[{"content":"What about these; why do they not compile?<pre data-lines=\"42,49\"><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Hawk</span> {\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">fly</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> numMiles)</span> {}\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">fly</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> numMiles)</span> {} <span class=\"hljs-comment\">// DOES NOT COMPILE</span>\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">fly</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> numKilometers)</span> {} <span class=\"hljs-comment\">// DOES NOT COMPILE</span>\n}\n</code></pre>","children":[{"content":"Again, the method signatures of these three methods are<br>\nthe same. You cannot declare methods in the same class<br>\nwhere the only difference is that one is an instance method<br>\nand one is a <code>static</code> method. You also cannot have two<br>\nmethods that have parameter lists with the same variable<br>\ntypes and in the same order. As we mentioned earlier, the<br>\nnames of the parameters in the list do not matter when<br>\ndetermining the method signature.","children":[{"content":"Calling overloaded methods is easy. For example,<br>\nlook at these two methods:<pre data-lines=\"59,69\"><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Dove</span> {\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">fly</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> numMiles)</span> {\n    System.out.println(<span class=\"hljs-string\">&quot;int&quot;</span>);\n  }\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">fly</span><span class=\"hljs-params\">(<span class=\"hljs-type\">short</span> numFeet)</span> {\n    System.out.println(<span class=\"hljs-string\">&quot;short&quot;</span>);\n  }\n}\n</code></pre>","children":[{"content":"The call <code>fly((short) 1)</code> prints <code>short</code>. It looks for matching types<br>\nand calls the appropriate method. Of course, it can be more<br>\ncomplicated than this.","children":[],"payload":{"tag":"li","lines":"69,72"}}],"payload":{"tag":"li","lines":"57,72"}}],"payload":{"tag":"li","lines":"49,72"}}],"payload":{"tag":"li","lines":"41,72"}}],"payload":{"tag":"li","lines":"30,72"}}],"payload":{"tag":"li","lines":"24,72"}}],"payload":{"tag":"li","lines":"14,72"}}],"payload":{"tag":"li","lines":"6,72"}},{"content":"<strong>Reference Types</strong><br>\nJava picks the most specific version of a method that<br>\nit can. What do you think this code outputs?<pre data-lines=\"75,91\"><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Pelican</span> {\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">fly</span><span class=\"hljs-params\">(String s)</span> {\n    System.out.print(<span class=\"hljs-string\">&quot;string&quot;</span>);\n  }\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">fly</span><span class=\"hljs-params\">(Object o)</span> {\n    System.out.print(<span class=\"hljs-string\">&quot;object&quot;</span>);\n  }\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> {\n    <span class=\"hljs-type\">var</span> <span class=\"hljs-variable\">p</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Pelican</span>();\n    p.fly(<span class=\"hljs-string\">&quot;test&quot;</span>);\n    System.out.print(<span class=\"hljs-string\">&quot;-&quot;</span>);\n    p.fly(<span class=\"hljs-number\">56</span>);\n  }\n}\n</code></pre>","children":[{"content":"The answer is <code>string-object</code>. The first call passes a <code>String</code><br>\nand finds a direct match. There&#x2019;s no reason to use the<br>\n<code>Object</code> version when there is a nice <code>String</code> parameter list just<br>\nwaiting to be called. The second call looks for an <code>int</code><br>\nparameter list. When it doesn&#x2019;t find one, it autoboxes to<br>\n<code>Integer</code>. Since it still doesn&#x2019;t find a match, it goes to the<br>\n<code>Object</code> one.","children":[{"content":"Let&#x2019;s try another. What does this print?<pre data-lines=\"99,119\"><code class=\"language-java\"><span class=\"hljs-keyword\">import</span> java.time.*;\n<span class=\"hljs-keyword\">import</span> java.util.*;\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Parrot</span> {\n <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">print</span><span class=\"hljs-params\">(List&lt;Integer&gt; i)</span> {\n   System.out.print(<span class=\"hljs-string\">&quot;I&quot;</span>);\n }\n <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">print</span><span class=\"hljs-params\">(CharSequence c)</span> {\n   System.out.print(<span class=\"hljs-string\">&quot;C&quot;</span>);\n }\n <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">print</span><span class=\"hljs-params\">(Object o)</span> {\n   System.out.print(<span class=\"hljs-string\">&quot;O&quot;</span>);\n }\n <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span>{\n   print(<span class=\"hljs-string\">&quot;abc&quot;</span>);\n   print(Arrays.asList(<span class=\"hljs-number\">3</span>));\n   print(LocalDate.of(<span class=\"hljs-number\">2019</span>, Month.JULY, <span class=\"hljs-number\">4</span>));\n }\n}\n</code></pre>","children":[{"content":"The answer is <code>CIO</code>. The code is due for a promotion! The<br>\nfirst call to <code>print()</code> passes a String. As you learned in<br>\nChapter 4, <code>String</code> and <code>StringBuilder</code> implement the<br>\n<code>CharSequence</code> interface. You also learned that <code>Arrays.asList()</code><br>\ncan be used to create a <code>List&lt;Integer&gt;</code> object, which explains<br>\nthe second output. The final call to <code>print()</code> passes a<br>\n<code>LocalDate</code>. This is a class you might not know, but that&#x2019;s OK.<br>\nIt clearly isn&#x2019;t a sequence of characters or a list. That<br>\nmeans the Object method signature is used.","children":[{"content":"<strong>Primitives</strong><br>\nPrimitives work in a way that&#x2019;s similar to reference<br>\nvariables. Java tries to find the most specific matching<br>\noverloaded method. What do you think happens here?<pre data-lines=\"132,148\"><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Ostrich</span> {\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">fly</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> i)</span> {\n    System.out.print(<span class=\"hljs-string\">&quot;int&quot;</span>);\n  }\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">fly</span><span class=\"hljs-params\">(<span class=\"hljs-type\">long</span> l)</span> {\n    System.out.print(<span class=\"hljs-string\">&quot;long&quot;</span>);\n  }\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> {\n    <span class=\"hljs-type\">var</span> <span class=\"hljs-variable\">p</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Ostrich</span>();\n    p.fly(<span class=\"hljs-number\">123</span>);\n    System.out.print(<span class=\"hljs-string\">&quot;-&quot;</span>);\n    p.fly(<span class=\"hljs-number\">123L</span>);\n  }\n}\n</code></pre>","children":[{"content":"The answer is <code>int-long</code>. The first call passes an <code>int</code> and sees<br>\nan exact match. The second call passes a <code>long</code> and also sees<br>\nan exact match. If we comment out the overloaded method<br>\nwith the <code>int</code> parameter list, the output becomes <code>long-long</code>.<br>\nJava has no problem calling a larger primitive. However, it<br>\nwill not do so unless a better match is not found.","children":[{"content":"<strong>Autoboxing</strong><br>\nAs we saw earlier, autoboxing applies to method calls, but<br>\nwhat happens if you have both a primitive and an integer<br>\nversion?<pre data-lines=\"158,164\"><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Kiwi</span> {\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">fly</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> numMiles)</span> {}\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">fly</span><span class=\"hljs-params\">(Integer numMiles)</span> {}\n}\n</code></pre>","children":[{"content":"These method overloads are valid. <em>Java tries to use the<br>\nmost specific parameter list it can find.</em> This is true for<br>\nautoboxing as well as other matching types we talk about in<br>\nthis section.<br>\nThis means calling <code>fly(3)</code> will call the first method. When<br>\nthe primitive <code>int</code> version isn&#x2019;t present, Java will autobox.<br>\nHowever, when the primitive <code>int</code> version is provided, there<br>\nis no reason for Java to do the extra work of autoboxing.","children":[{"content":"<strong>Arrays</strong><br>\nUnlike the previous example, this code does not result in<br>\nautoboxing:<pre data-lines=\"175,179\"><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">walk</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span>[] ints)</span> {}\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">walk</span><span class=\"hljs-params\">(Integer[] integers)</span> {}\n</code></pre>\nArrays have been around since the beginning of Java. They<br>\nspecify their actual types.","children":[],"payload":{"tag":"li","lines":"172,181"}}],"payload":{"tag":"li","lines":"164,181"}}],"payload":{"tag":"li","lines":"154,181"}}],"payload":{"tag":"li","lines":"148,181"}}],"payload":{"tag":"li","lines":"128,181"}}],"payload":{"tag":"li","lines":"119,181"}}],"payload":{"tag":"li","lines":"98,181"}}],"payload":{"tag":"li","lines":"91,181"}}],"payload":{"tag":"li","lines":"72,181"}},{"content":"<strong>Varargs</strong><br>\nWhich method do you think is called if we pass an <code>int[]</code>?<pre data-lines=\"183,189\"><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Toucan</span> {\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">fly</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span>[] lengths)</span> {}\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">fly</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span>&#x2026; lengths)</span> {} <span class=\"hljs-comment\">// DOES NOT COMPILE</span>\n}\n</code></pre>","children":[{"content":"Trick question! Remember that Java treats varargs as if they were<br>\nan array. This means the method signature is the same for both<br>\nmethods. Since we are not allowed to overload methods with the<br>\nsame parameter list, this code doesn&#x2019;t compile. Even though the<br>\ncode doesn&#x2019;t look the same, it compiles to the same parameter list.","children":[{"content":"\n<p data-lines=\"194,198\">Now that we&#x2019;ve just gotten through explaining that the two<br>\nmethods are similar, it is time to mention how they are<br>\ndifferent. It shouldn&#x2019;t be a surprise that you can call either<br>\nmethod by passing an array:</p>\n<pre data-lines=\"198,202\"><code class=\"language-java\"><span class=\"hljs-comment\">// Allowed to call either fly() method</span>\nfly(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">int</span>[] { <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span> });\n</code></pre>\n<p data-lines=\"203,205\">However, you can only call the varargs version with stand-<br>\nalone parameters:</p>\n<pre data-lines=\"205,209\"><code class=\"language-java\"><span class=\"hljs-comment\">// Allowed to call only the fly() method using varargs</span>\nfly(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>);\n</code></pre>","children":[{"content":"<strong>Putting It All Together</strong><br>\nSo far, all the rules for when an overloaded method is<br>\ncalled should be logical. Java calls the most specific method<br>\nit can. When some of the types interact, the Java rules focus<br>\non backward compatibility. A long time ago, autoboxing<br>\nand varargs didn&#x2019;t exist. Since old code still needs to work,<br>\nthis means autoboxing and varargs come last when Java<br>\nlooks at overloaded methods. Ready for the official order?<br>\n<strong>Table 5.6</strong> lays it out for you.","children":[{"content":"<strong>TABLE 5.6</strong> The order that Java uses to choose the right<br>\noverloaded method\n<table data-lines=\"220,226\">\n<thead data-lines=\"220,221\">\n<tr data-lines=\"220,221\">\n<th>Rule</th>\n<th>Example of what will be chosen<br> for <code>glide(1,2)</code></th>\n</tr>\n</thead>\n<tbody data-lines=\"222,226\">\n<tr data-lines=\"222,223\">\n<td>Exact match by type</td>\n<td><code>int glide(int i, int j)</code></td>\n</tr>\n<tr data-lines=\"223,224\">\n<td>Larger primitive type</td>\n<td><code>int glide(long i, long j)</code></td>\n</tr>\n<tr data-lines=\"224,225\">\n<td>Autoboxed type</td>\n<td><code>int glide(Integer i, Integer j)</code></td>\n</tr>\n<tr data-lines=\"225,226\">\n<td>Varargs</td>\n<td><code>int glide(int&#x2026; nums)</code></td>\n</tr>\n</tbody>\n</table>","children":[{"content":"Let&#x2019;s give this a practice run using the rules in Table 5.6.<br>\nWhat do you think this outputs?<pre data-lines=\"228,249\"><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Glider</span> {\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> String <span class=\"hljs-title function_\">glide</span><span class=\"hljs-params\">(String s)</span> {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;1&quot;</span>;\n  }\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> String <span class=\"hljs-title function_\">glide</span><span class=\"hljs-params\">(String&#x2026; s)</span> {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;2&quot;</span>;\n  }\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> String <span class=\"hljs-title function_\">glide</span><span class=\"hljs-params\">(Object o)</span> {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;3&quot;</span>;\n  }\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> String <span class=\"hljs-title function_\">glide</span><span class=\"hljs-params\">(String s, String t)</span> {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;4&quot;</span>;\n  }\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> {\n    System.out.print(glide(<span class=\"hljs-string\">&quot;a&quot;</span>));\n    System.out.print(glide(<span class=\"hljs-string\">&quot;a&quot;</span>, <span class=\"hljs-string\">&quot;b&quot;</span>));\n    System.out.print(glide(<span class=\"hljs-string\">&quot;a&quot;</span>, <span class=\"hljs-string\">&quot;b&quot;</span>, <span class=\"hljs-string\">&quot;c&quot;</span>));\n  }\n}\n</code></pre>","children":[{"content":"It prints out <code>142</code>. The first call matches the signature taking<br>\na single <code>String</code> because that is the most specific match. The<br>\nsecond call matches the signature taking two <code>String</code><br>\nparameters since that is an exact match. It isn&#x2019;t until the<br>\nthird call that the varargs version is used since there are no<br>\nbetter matches.","children":[],"payload":{"tag":"li","lines":"249,255"}}],"payload":{"tag":"li","lines":"226,255"}}],"payload":{"tag":"li","lines":"218,255"}}],"payload":{"tag":"li","lines":"209,255"}}],"payload":{"tag":"li","lines":"194,255"}}],"payload":{"tag":"li","lines":"189,255"}}],"payload":{"tag":"li","lines":"181,255"}}],"payload":{"tag":"h1","lines":"5,6"}},{"initialExpandLevel":1})</script>
</body>
</html>
