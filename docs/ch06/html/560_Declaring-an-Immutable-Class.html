<!doctype html>
<html>
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta http-equiv="X-UA-Compatible" content="ie=edge" />
<title>Markmap</title>
<style>
* {
  margin: 0;
  padding: 0;
}
html {
  font-family: ui-sans-serif, system-ui, sans-serif, 'Apple Color Emoji',
    'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji';
}
#mindmap {
  display: block;
  width: 100vw;
  height: 100vh;
}
.markmap-dark {
  background: #27272a;
  color: white;
}
</style>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/markmap-toolbar@0.18.12/dist/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@highlightjs/cdn-assets@11.11.1/styles/default.min.css">
</head>
<body>
<svg id="mindmap"></svg>
<script src="https://cdn.jsdelivr.net/npm/d3@7.9.0/dist/d3.min.js"></script><script src="https://cdn.jsdelivr.net/npm/markmap-view@0.18.12/dist/browser/index.js"></script><script src="https://cdn.jsdelivr.net/npm/markmap-toolbar@0.18.12/dist/index.js"></script><script>(r => {
              setTimeout(r);
            })(function renderToolbar() {
  const {
    markmap,
    mm
  } = window;
  const {
    el
  } = markmap.Toolbar.create(mm);
  el.setAttribute('style', 'position:absolute;bottom:20px;right:20px');
  document.body.append(el);
})</script><script>((getMarkmap, getOptions, root2, jsonOptions) => {
              const markmap = getMarkmap();
              window.mm = markmap.Markmap.create(
                "svg#mindmap",
                (getOptions || markmap.deriveOptions)(jsonOptions),
                root2
              );
              if (window.matchMedia("(prefers-color-scheme: dark)").matches) {
                document.documentElement.classList.add("markmap-dark");
              }
            })(() => window.markmap,null,{"content":"<strong>Declaring an Immutable Class</strong>","children":[{"content":"You should be familiar with a common strategy<br>\nfor making a class immutable:","children":[{"content":"1.- Mark the class as <code>final</code> or make all of the constructors <code>private</code>.<br>\n2.- Mark all the instance variables <code>private</code> and <code>final</code>.<br>\n3.- Don&#x2019;t define any setter methods<br>\n4.- Don&#x2019;t allow referenced mutable objects to be modified.<br>\n5.- Use a constructor to set all properties of the object, making<br>\n&#xa0; &#xa0; &#xa0;&#xa0;a copy if needed.","children":[{"content":"The first rule prevents anyone from creating a mutable subclass. The second<br>\nand third rules ensure that callers don&#x2019;t make changes to instance variables.<br>\nThe fourth rule means that you shouldn&#x2019;t expose an accessor (or getter)<br>\nmethod for mutable instance fields. Can you see why the following creates a<br>\nmutable object?","children":[{"content":"\n<pre data-lines=\"19,31\"><code class=\"language-java\"><span class=\"hljs-keyword\">import</span> java.util.*;\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Animal</span> { <span class=\"hljs-comment\">// Not an immutable object declaration</span>\n  <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> ArrayList&lt;String&gt; favoriteFoods;\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">Animal</span><span class=\"hljs-params\">()</span> {\n    <span class=\"hljs-built_in\">this</span>.favoriteFoods = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ArrayList</span>&lt;String&gt;();\n    <span class=\"hljs-built_in\">this</span>.favoriteFoods.add(<span class=\"hljs-string\">&quot;Apples&quot;</span>);\n  }\n  <span class=\"hljs-keyword\">public</span> List&lt;String&gt; <span class=\"hljs-title function_\">getFavoriteFoods</span><span class=\"hljs-params\">()</span> {\n    <span class=\"hljs-keyword\">return</span> favoriteFoods;\n  } }\n</code></pre>","children":[{"content":"We carefully followed the first three rules, but unfortunately, a malicious caller could<br>\nstill modify our data.<pre data-lines=\"33,41\"><code class=\"language-java\"><span class=\"hljs-type\">var</span> <span class=\"hljs-variable\">zebra</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Animal</span>();\nSystem.out.println(zebra.getFavoriteFoods()); <span class=\"hljs-comment\">// [Apples]</span>\n\nzebra.getFavoriteFoods().clear();\nzebra.getFavoriteFoods().add(<span class=\"hljs-string\">&quot;Chocolate Chip Cookies&quot;</span>);\nSystem.out.println(zebra.getFavoriteFoods()); <span class=\"hljs-comment\">// [Chocolate Chip Cookies]</span>\n</code></pre>","children":[{"content":"It&#x2019;s not an immutable object if we can change its contents! If we don&#x2019;t have a getter<br>\nfor the <code>favoriteFoods</code> object, how do callers access it? Simple: by using delegate<br>\nor wrapper methods to read the data.","children":[],"payload":{"tag":"li","lines":"41,44"}}],"payload":{"tag":"li","lines":"31,44"}}],"payload":{"tag":"li","lines":"19,44"}}],"payload":{"tag":"li","lines":"14,44"}}],"payload":{"tag":"li","lines":"8,44"}}],"payload":{"tag":"li","lines":"6,44"}},{"content":"\n<pre data-lines=\"44,59\"><code class=\"language-java\"><span class=\"hljs-keyword\">import</span> java.util.*;\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Animal</span> { <span class=\"hljs-comment\">// An immutable object declaration</span>\n  <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> List&lt;String&gt; favoriteFoods;\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">Animal</span><span class=\"hljs-params\">()</span> {\n    <span class=\"hljs-built_in\">this</span>.favoriteFoods = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ArrayList</span>&lt;String&gt;();\n    <span class=\"hljs-built_in\">this</span>.favoriteFoods.add(<span class=\"hljs-string\">&quot;Apples&quot;</span>);\n  }\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">getFavoriteFoodsCount</span><span class=\"hljs-params\">()</span> {\n    <span class=\"hljs-keyword\">return</span> favoriteFoods.size();\n  }\n  <span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title function_\">getFavoriteFoodsItem</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> index)</span> {\n    <span class=\"hljs-keyword\">return</span> favoriteFoods.get(index);\n  } }\n</code></pre>","children":[{"content":"In this improved version, the data is still available. However, it is a true immutable<br>\nobject because the mutable variable cannot be modified the caller.","children":[{"content":"<strong>Copy on Read Accessor Methods</strong><br>\nBesides delegating access to any <code>private</code> mutable objects, another<br>\napproach is to make a copy of the mutable object  any time it is<br>\nrequested.<pre data-lines=\"65,70\"><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> ArrayList&lt;String&gt; <span class=\"hljs-title function_\">getFavoriteFoods</span><span class=\"hljs-params\">()</span> {\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ArrayList</span>&lt;String&gt;(<span class=\"hljs-built_in\">this</span>.favoriteFoods);\n}\n</code></pre>\nOf course, changes in the copy won&#x2019;t be reflected in the original,<br>\nbut at least the original is protected from external changes. This<br>\ncan be an expensive operation if called frequently by the caller.","children":[{"content":"<strong>Performing a Defensive Copy</strong><br>\nSo, what&#x2019;s this about the fifth and final rule for creating immutable objects? In designing our class,<br>\nlet&#x2019;s say we want a rule that the data for <code>favoriteFoods</code> is provided by the caller and that it always<br>\ncontains at least one element. This rule is often called an invariant; it is true any time we have<br>\nan instance of the object.","children":[{"content":"\n<pre data-lines=\"78,93\"><code class=\"language-java\"><span class=\"hljs-keyword\">import</span> java.util.*;\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Animal</span> { <span class=\"hljs-comment\">// Not an immutable object declaration</span>\n  <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> ArrayList&lt;String&gt; favoriteFoods;\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">Animal</span><span class=\"hljs-params\">(ArrayList&lt;String favoriteFoods)</span> {\n    <span class=\"hljs-keyword\">if</span> (favoriteFoods == <span class=\"hljs-literal\">null</span> || favoriteFoods.size() == <span class=\"hljs-number\">0</span>)\n      <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">RuntimeException</span>(<span class=\"hljs-string\">&quot;favoriteFoods is required&quot;</span>);\n    <span class=\"hljs-built_in\">this</span>.favoriteFoods = favoriteFoods;\n  }\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">getFavoriteFoodsCount</span><span class=\"hljs-params\">()</span> {\n    <span class=\"hljs-keyword\">return</span> favoriteFoods.size();}\n  <span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title function_\">getFavoriteFoodsItem</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> index)</span> {\n    <span class=\"hljs-keyword\">return</span> favoriteFoods.get(index);\n  } }\n</code></pre>","children":[{"content":"To ensure that <code>favoriteFoods</code> is provided, we validate it in the constructor and throw<br>\nan exception if it is not provided. So is this immutable? Not quite! A malicious caller<br>\nmight be tricky and keep their own secret reference to our <code>favoriteFoods</code> object,<br>\nwhich they can modify directly.","children":[],"payload":{"tag":"li","lines":"93,97"}}],"payload":{"tag":"li","lines":"78,97"}}],"payload":{"tag":"li","lines":"73,97"}}],"payload":{"tag":"li","lines":"61,97"}}],"payload":{"tag":"li","lines":"59,97"}}],"payload":{"tag":"li","lines":"44,97"}},{"content":"\n<pre data-lines=\"97,108\"><code class=\"language-java\"><span class=\"hljs-type\">var</span> <span class=\"hljs-variable\">favorites</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ArrayList</span>&lt;String&gt;();\nfavorites.add(<span class=\"hljs-string\">&quot;Apples&quot;</span>);\n\n<span class=\"hljs-type\">var</span> <span class=\"hljs-variable\">zebra</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Animal</span>(favorites); <span class=\"hljs-comment\">// Caller still has access to favorites</span>\nSystem.out.println(zebra.getFavoriteFoodsItem(<span class=\"hljs-number\">0</span>)); <span class=\"hljs-comment\">// [Apples]</span>\n\nfavorites.clear();\nfavorites.add(<span class=\"hljs-string\">&quot;Chocolate Chip Cookies&quot;</span>);\nSystem.out.println(zebra.getFavoriteFoodsItem(<span class=\"hljs-number\">0</span>)); <span class=\"hljs-comment\">//[Chocolate Chip Cookies]</span>\n</code></pre>","children":[{"content":"It seems like Animal is not immutable anymore, since its contents can<br>\nchange after it is created. The solution is to make a copy of the list<br>\nobject containing the same elements.<pre data-lines=\"111,118\"><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">Animal</span><span class=\"hljs-params\">(List&lt;String&gt; favoriteFoods)</span> {\n  <span class=\"hljs-keyword\">if</span> (favoriteFoods == <span class=\"hljs-literal\">null</span> || favoriteFoods.size() == <span class=\"hljs-number\">0</span>)\n    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">RuntimeException</span>(<span class=\"hljs-string\">&quot;favoriteFoods is required&quot;</span>);\n  <span class=\"hljs-built_in\">this</span>.favoriteFoods = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ArrayList</span>&lt;String&gt; (favoriteFoods);\n}\n</code></pre>","children":[{"content":"The copy operation is called a defensive copy because the copy is being<br>\nmade in case other code does something unexpected. It&#x2019;s the same idea<br>\nas defensive driving:<br>\nprevent a problem before it exists. With this approach, our <code>Animal</code> class<br>\nis once again immutable.","children":[],"payload":{"tag":"li","lines":"118,123"}}],"payload":{"tag":"li","lines":"108,123"}}],"payload":{"tag":"li","lines":"97,123"}}],"payload":{"tag":"h1","lines":"5,6"}},{"initialExpandLevel":1})</script>
</body>
</html>
