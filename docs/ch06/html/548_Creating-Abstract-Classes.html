<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<title>Markmap</title>
<style>
* {
  margin: 0;
  padding: 0;
}
#mindmap {
  display: block;
  width: 100vw;
  height: 100vh;
}
</style>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@highlightjs/cdn-assets@11.11.1/styles/default.min.css">
</head>
<body>
<svg id="mindmap"></svg>
<script src="https://cdn.jsdelivr.net/npm/d3@7.9.0/dist/d3.min.js"></script><script src="https://cdn.jsdelivr.net/npm/markmap-view@0.18.10/dist/browser/index.js"></script><script src="https://cdn.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/index.js"></script><script>(r => {
              setTimeout(r);
            })(function renderToolbar() {
  const {
    markmap,
    mm
  } = window;
  const {
    el
  } = markmap.Toolbar.create(mm);
  el.setAttribute('style', 'position:absolute;bottom:20px;right:20px');
  document.body.append(el);
})</script><script>((getMarkmap, getOptions, root2, jsonOptions) => {
              const markmap = getMarkmap();
              window.mm = markmap.Markmap.create(
                "svg#mindmap",
                (getOptions || markmap.deriveOptions)(jsonOptions),
                root2
              );
            })(() => window.markmap,null,{"content":"<strong>Creating Abstract Classes</strong>","children":[{"content":"An abstract class is a class declared with the <code>abstract</code> modifier that cannot be instantiated<br>\ndirectly and may contain abstract methods. Let&#x2019;s take a look at an example based on the<br>\n<code>Canine</code> data model:<pre data-lines=\"9,16\"><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Canine</span> {}\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Wolf</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">Canine</span> {}\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Fox</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">Canine</span> {}\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Coyote</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">Canine</span> {}\n</code></pre>","children":[{"content":"In this example, you can create instances of <code>Wolf</code>, <code>Fox</code>, or <code>Coyote</code>, but not <code>Canine</code>.<br>\nSure, they can pass a variable reference as a <code>Canine</code>, but the underlying object<br>\nmust be a subclass of <code>Canine</code> at runtime.<br>\nBut wait, there&#x2019;s more! An abstract class can contain abstract methods. An abstract<br>\nmethod is a method declared with the <code>abstract</code> modifier that does not define a body.<br>\nAn abstract method forces subclasses to override the method.","children":[{"content":"Why would we want this? Polymorphism, of course! By   declaring a method abstract, we can<br>\nguarantee that some version will be available on an instance without having to specify what<br>\nthat version is in the abstract parent class.","children":[{"content":"\n<pre data-lines=\"25,43\"><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Canine</span> {\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> String <span class=\"hljs-title function_\">getSound</span><span class=\"hljs-params\">()</span>;\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">bark</span><span class=\"hljs-params\">()</span> { System.out.println(getSound()); }\n}\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Wolf</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">Canine</span> {\n  <span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title function_\">getSound</span><span class=\"hljs-params\">()</span> {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;Wooooooof!&quot;</span>;\n  } }\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Fox</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">Canine</span> {\n  <span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title function_\">getSound</span><span class=\"hljs-params\">()</span> {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;Squeak!&quot;</span>;\n  } }\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Coyote</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">Canine</span> {\n  <span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title function_\">getSound</span><span class=\"hljs-params\">()</span> {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;Roar!&quot;</span>;\n  } }\n</code></pre>","children":[{"content":"We can then create an instance of <code>Fox</code> and assign it to the parent type <code>Canine</code>.<strong style=\"color:green\">The<br>\noverridden method will be used at runtime.</strong><pre data-lines=\"45,51\"><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] p)</span> {\n  <span class=\"hljs-type\">Canine</span> <span class=\"hljs-variable\">w</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Fox</span>();\n  w.bark(); <span class=\"hljs-comment\">// Squeak!</span>\n}\n</code></pre>","children":[{"content":"There are some rules you need to be aware of:<br>\n* Only instance methods can be marked <code>abstract</code> within a class, not variables, constructors,<br>\nor <code>static</code> methods.<br>\n* An abstract class can include zero or more abstract methods, while a non-abstract class<br>\ncannot contain any.<br>\n* A non-abstract class that extends an abstract class must implement all inherited abstract<br>\nmethods.<br>\n* Overriding an abstract method follows the existing rules for overriding methods that you<br>\nlearned about earlier.","children":[{"content":"Let&#x2019;s see if you can spot why each of these class<br>\ndeclarations does not compile:<pre data-lines=\"62,82\"><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">FennecFox</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">Canine</span> {\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">getSound</span><span class=\"hljs-params\">()</span> {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">10</span>;\n  } }\n  \n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ArcticFox</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">Canine</span> {}\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Direwolf</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">Canine</span> {\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-title function_\">rest</span><span class=\"hljs-params\">()</span>;\n  <span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title function_\">getSound</span><span class=\"hljs-params\">()</span> {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;Roof!&quot;</span>;\n  } }\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Jackal</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">Canine</span> {\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> String name;\n  <span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title function_\">getSound</span><span class=\"hljs-params\">()</span> {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;Laugh&quot;</span>;\n  } }\n</code></pre>","children":[{"content":"First off, the <code>FennecFox</code> class does not compile because it is an invalid method override.<br>\nIn particular, the return types are not covariant. The <code>ArcticFox</code> class does not compile<br>\nbecause it does not override the abstract <code>getSound()</code> method. The <code>Direwolf</code> class does<br>\nnot compile because it is not abstract but declares an abstract method <code>rest()</code>. Finally,<br>\nthe <code>Jackal</code> class does not compile because variables cannot be marked abstract.","children":[],"payload":{"tag":"li","lines":"82,87"}}],"payload":{"tag":"li","lines":"60,87"}}],"payload":{"tag":"li","lines":"51,87"}}],"payload":{"tag":"li","lines":"43,87"}}],"payload":{"tag":"li","lines":"25,87"}}],"payload":{"tag":"li","lines":"22,87"}}],"payload":{"tag":"li","lines":"16,87"}}],"payload":{"tag":"li","lines":"6,87"}},{"content":"An abstract class is most commonly used when you want another class to inherit<br>\nproperties of a particular class, but you want the subclass to fill in some of the<br>\nimplementation details.<br>\nEarlier, we said that an abstract class is one that cannot be instantiated. This<br>\nmeans that if you attempt to instantiate it, the compiler will report a compiler error,<br>\nas in this example:<pre data-lines=\"93,100\"><code class=\"language-java\"><span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Alligator</span> {\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String&#x2026; food)</span> {\n    <span class=\"hljs-type\">var</span> <span class=\"hljs-variable\">a</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Alligator</span>(); <span class=\"hljs-comment\">// DOES NOT COMPILE</span>\n  }\n}\n</code></pre>\nAn abstract class can be initialized, but only as part of the instantiation of a<br>\nnon-abstract subclass.","children":[{"content":"<strong>Declaring Abstract Methods</strong><br>\nAn abstract method is always declared without a body. It also includes a semicolon (;)<br>\nafter the method declaration. As you saw in the previous example, an abstract class<br>\nmay include non-abstract methods, in this case with the <code>bark()</code> method. In fact, an<br>\nabstract class can include all of the same members as a non-abstract class, including<br>\nvariables, <code>static</code> and instance methods, constructors, etc.","children":[{"content":"It might surprise you to know that an abstract class is not required to include any abstract<br>\nmethods. For example, the following code compiles even though it doesn&#x2019;t define any<br>\nabstract methods:<pre data-lines=\"111,116\"><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Llama</span> {\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">chew</span><span class=\"hljs-params\">()</span> {}\n}\n</code></pre>","children":[{"content":"Even without abstract methods, the class cannot be directly instantiated. For the exam, keep an<br>\neye out for abstract methods declared outside abstract classes, such as the following:<pre data-lines=\"118,123\"><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Egret</span> { <span class=\"hljs-comment\">// DOES NOT COMPILE</span>\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">peck</span><span class=\"hljs-params\">()</span>;\n}\n</code></pre>","children":[{"content":"The <code>abstract</code> modifier can be placed before or after the access modifier<br>\nin class and method declarations, as shown in this <code>Tiger</code> class:<pre data-lines=\"125,130\"><code class=\"language-java\"><span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Tiger</span> {\n  <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">claw</span><span class=\"hljs-params\">()</span>;\n}\n</code></pre>","children":[{"content":"The <code>abstract</code> modifier cannot be placed after the <code>class</code> keyword in a class declaration or<br>\nafter the return type in a method declaration. The following <code>Bear</code> and <code>howl()</code> declarations<br>\ndo not compile for these reasons:<pre data-lines=\"133,138\"><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">abstract</span> Bear { <span class=\"hljs-comment\">// DOES NOT COMPILE</span>\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-title function_\">howl</span><span class=\"hljs-params\">()</span>; <span class=\"hljs-comment\">// DOES NOT COMPILE</span>\n}\n</code></pre>","children":[{"content":"<strong>Creating a Concrete Class</strong><br>\nA concrete class is a non-abstract class. The first concrete subclass that extends<br>\nan abstract class is required to implement all inherited abstract methods.","children":[],"payload":{"tag":"li","lines":"138,141"}}],"payload":{"tag":"li","lines":"130,141"}}],"payload":{"tag":"li","lines":"123,141"}}],"payload":{"tag":"li","lines":"116,141"}}],"payload":{"tag":"li","lines":"108,141"}}],"payload":{"tag":"li","lines":"102,141"}}],"payload":{"tag":"li","lines":"87,141"}},{"content":"When you see a concrete class extending an abstract class on the exam, check<br>\nto make sure that it implements all of the required abstract methods. Can you see<br>\nwhy the following <code>Walrus</code> class does not compile?<pre data-lines=\"144,150\"><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Animal</span> {\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> String <span class=\"hljs-title function_\">getName</span><span class=\"hljs-params\">()</span>;\n}\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Walrus</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">Animal</span> {} <span class=\"hljs-comment\">// DOES NOT COMPILE</span>\n</code></pre>","children":[{"content":"In this example, we see that <code>Animal</code> is marked as <code>abstract</code> and <code>Walrus</code> is not, making<br>\n<code>Walrus</code> a concrete subclass of <code>Animal</code>. Since <code>Walrus</code> is the first concrete subclass,<br>\nit must implement all inherited abstract methods <code>getName()</code> in this example. Because<br>\nit doesn&#x2019;t, the compiler reports an error with the declaration of <code>Walrus</code>.","children":[{"content":"We highlight the first concrete subclass for a reason. <strong style=\"color:green\">An abstract class can extend a<br>\nnon-abstract class and vice versa.</strong> Anytime a concrete class is extending an abstract<br>\nclass, it must implement all of the methods that are inherited as abstract. Let&#x2019;s<br>\nillustrate this with a set of inherited classes:<pre data-lines=\"158,170\"><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Mammal</span> {\n  <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">showHorn</span><span class=\"hljs-params\">()</span>;\n  <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">eatLeaf</span><span class=\"hljs-params\">()</span>;\n}\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Rhino</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">Mammal</span> {\n  <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">showHorn</span><span class=\"hljs-params\">()</span> {} <span class=\"hljs-comment\">// Inherited from Mammal</span>\n}\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">BlackRhino</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">Rhino</span> {\n  <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">eatLeaf</span><span class=\"hljs-params\">()</span> {} <span class=\"hljs-comment\">// Inherited from Mammal</span>\n}\n</code></pre>","children":[{"content":"In this example, the <code>BlackRhino</code> class is the first concrete subclass, while the <code>Mammal</code> and <code>Rhino</code><br>\nclasses are abstract. The <code>BlackRhino</code> class inherits the <code>eatLeaf()</code> method as abstract and is<br>\ntherefore required to provide an implementation, which it does.<br>\nWhat about the <code>showHorn()</code> method? Since the parent class, <code>Rhino</code>, provides an implementation<br>\nof <code>showHorn()</code>, the method is inherited in the <code>BlackRhino</code> as a non-abstract method. For this reason,<br>\nthe <code>BlackRhino</code> class is permitted but not required to override the <code>showHorn()</code> method. The three<br>\nclasses in this example are correctly defined and compile.","children":[{"content":"What if we changed the Rhino declaration to remove the <code>abstract</code> modifier?<pre data-lines=\"178,183\"><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Rhino</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">Mammal</span> { <span class=\"hljs-comment\">// DOES NOT COMPILE</span>\n  <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">showHorn</span><span class=\"hljs-params\">()</span> {}\n}\n</code></pre>\nBy changing <code>Rhino</code> to a concrete class, it becomes the first non-abstract<br>\nclass to extend the abstract <code>Mammal</code> class. Therefore, it must provide an<br>\nimplementation of both the <code>showHorn()</code> and <code>eatLeaf()</code> methods. Since it<br>\nonly provides one of these methods, the modified Rhino declaration does<br>\nnot compile.","children":[{"content":"Let&#x2019;s try one more example. The following concrete class <code>Lion</code> inherits<br>\ntwo abstract methods, <code>getName()</code> and <code>roar()</code>:<pre data-lines=\"190,206\"><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Animal</span> {\n  <span class=\"hljs-keyword\">abstract</span> String <span class=\"hljs-title function_\">getName</span><span class=\"hljs-params\">()</span>;\n}\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">BigCat</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">Animal</span> {\n  <span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">roar</span><span class=\"hljs-params\">()</span>;\n}\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Lion</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">BigCat</span> {\n  <span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title function_\">getName</span><span class=\"hljs-params\">()</span> {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;Lion&quot;</span>;\n  }\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">roar</span><span class=\"hljs-params\">()</span> {\n    System.out.println(<span class=\"hljs-string\">&quot;The Lion lets out a loud ROAR!&quot;</span>);\n  }\n}\n</code></pre>","children":[{"content":"In this sample code, <code>BigCat</code> extends <code>Animal</code> but is marked as <code>abstract</code>; therefore, it is not<br>\nrequired to provide an implementation for the <code>getName()</code> method. The class <code>Lion</code> is not<br>\nmarked as <code>abstract</code>, and as the first concrete subclass, it must implement all of the<br>\ninherited abstract methods not defined in a parent class. All three of these classes compile<br>\nsuccessfully.","children":[],"payload":{"tag":"li","lines":"206,211"}}],"payload":{"tag":"li","lines":"188,211"}}],"payload":{"tag":"li","lines":"177,211"}}],"payload":{"tag":"li","lines":"170,211"}}],"payload":{"tag":"li","lines":"154,211"}}],"payload":{"tag":"li","lines":"150,211"}}],"payload":{"tag":"li","lines":"141,211"}},{"content":"<strong>Creating Constructors in Abstract Classes</strong><br>\nEven though abstract classes cannot be instantiated, they are still initialized through<br>\nconstructors by their subclasses. For example, consider the following program:<pre data-lines=\"214,228\"><code class=\"language-java\"><span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Mammal</span> {\n<span class=\"hljs-keyword\">abstract</span> CharSequence <span class=\"hljs-title function_\">chew</span><span class=\"hljs-params\">()</span>;\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">Mammal</span><span class=\"hljs-params\">()</span> {\n    System.out.println(chew()); <span class=\"hljs-comment\">// Does this line compile?</span>\n  }\n}\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Platypus</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">Mammal</span> {\n  String <span class=\"hljs-title function_\">chew</span><span class=\"hljs-params\">()</span> { <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;yummy!&quot;</span>; }\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> {\n    <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Platypus</span>();\n  }\n}\n</code></pre>","children":[{"content":"Using the constructor rules you learned about earlier in this chapter, the compiler<br>\ninserts a default no-argument constructor into the <code>Platypus</code> class, which first calls<br>\n<code>super()</code> in the <code>Mammal</code> class. The <code>Mammal</code> constructor is only called when the<br>\nabstract class is being initialized through a subclass; therefore, there is an<br>\nimplementation of <code>chew()</code> at the time the constructor is called. This code compiles<br>\nand prints <code>yummy!</code> at runtime.","children":[{"content":"For the exam, remember that abstract classes are initialized with constructors in the same<br>\nway as non-abstract classes. For example, if an abstract class does not provide a<br>\nconstructor, the compiler will automatically insert a default no-argument constructor.<br>\nThe primary difference between a constructor in an abstract class and a non-abstract class<br>\nis that a constructor in an abstract class can be called only when it is being initialized by a<br>\nnon-abstract subclass.","children":[{"content":"<strong>Spotting Invalid Declarations</strong><br>\nCan you see why each of the following methods does not compile?<pre data-lines=\"242,253\"><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Turtle</span> {\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-type\">long</span> <span class=\"hljs-title function_\">eat</span><span class=\"hljs-params\">()</span> <span class=\"hljs-comment\">// DOES NOT COMPILE</span>\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">swim</span><span class=\"hljs-params\">()</span> {}; <span class=\"hljs-comment\">// DOES NOT COMPILE</span>\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">getAge</span><span class=\"hljs-params\">()</span> { <span class=\"hljs-comment\">// DOES NOT COMPILE</span>\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">10</span>;\n  }\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-keyword\">void</span> sleep; <span class=\"hljs-comment\">// DOES NOT COMPILE</span>\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">goInShell</span><span class=\"hljs-params\">()</span>; <span class=\"hljs-comment\">// DOES NOT COMPILE</span>\n}\n</code></pre>","children":[{"content":"The first method, <code>eat()</code>, does not compile because it is marked <code>abstract</code> but does not end with<br>\na semicolon (;). The next two methods, <code>swim()</code> and <code>getAge()</code>, do not compile because they are<br>\nmarked <code>abstract</code>, but they provide an implementation block enclosed in braces (<code>{}</code>). For the<br>\nexam, remember that an abstract method declaration must end in a semicolon without any<br>\nbraces. The next method, <code>sleep</code>, does not compile because it is missing parentheses, <code>()</code>, for<br>\nmethod arguments. The last method, <code>goInShell()</code>, does not compile because it is not marked<br>\n<code>abstract</code> and therefore must provide a body enclosed in braces.<br>\nIf you come across a question on the exam in which a class or method is marked <code>abstract</code>,<br>\nmake sure the class is properly implemented before attempting to solve the problem.","children":[{"content":"<strong><code>abstract</code> and <code>final</code> Modifiers</strong><br>\nThese concepts are in direct conflict with each other.<pre data-lines=\"264,269\"><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Tortoise</span> { <span class=\"hljs-comment\">// DOES NOT COMPILE</span>\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">walk</span><span class=\"hljs-params\">()</span>; <span class=\"hljs-comment\">// DOES NOT COMPILE</span>\n}\n</code></pre>\nIn this example, neither the class nor the method declarations will compile<br>\nbecause they are marked both <code>abstract</code> and <code>final</code>. The exam doesn&#x2019;t tend<br>\nto use <code>final</code> modifiers on classes or methods often, so if you see them,<br>\nmake sure they aren&#x2019;t used with the <code>abstract</code> modifier.","children":[{"content":"<strong><code>abstract</code> and <code>private</code> Modifiers</strong><br>\nA method cannot be marked as both <code>abstract</code> and <code>private</code>.<pre data-lines=\"275,284\"><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Whale</span> {\n  <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">sing</span><span class=\"hljs-params\">()</span>; <span class=\"hljs-comment\">// DOES NOT COMPILE</span>\n}\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">HumpbackWhale</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">Whale</span> {\n  <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">sing</span><span class=\"hljs-params\">()</span> {\n    System.out.println(<span class=\"hljs-string\">&quot;Humpback whale is singing&quot;</span>);\n} }\n</code></pre>\nIn this example, the abstract method <code>sing()</code> defined in the parent<br>\nclass <code>Whale</code> is not visible to the subclass <code>HumpbackWhale</code>.<br>\nEven though <code>HumpbackWhale</code> does provide an implementation,<br>\nit is not considered an override of the abstract method<br>\nsince the abstract method is not inherited.","children":[{"content":"If we changed the access modifier from <code>private</code> to <code>protected</code> in the parent class <code>Whale</code>,<br>\nwould the code compile?<pre data-lines=\"291,301\"><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Whale</span> {\n  <span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">sing</span><span class=\"hljs-params\">()</span>;\n}\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">HumpbackWhale</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">Whale</span> {\n  <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">sing</span><span class=\"hljs-params\">()</span> { <span class=\"hljs-comment\">// DOES NOT COMPILE</span>\n    System.out.println(<span class=\"hljs-string\">&quot;Humpback whale is singing&quot;</span>);\n  }\n}\n</code></pre>\nIn this modified example, the code will still not compile, but for a completely different reason.<br>\nIf you remember the rules for overriding a method, the subclass cannot reduce the visibility<br>\nof the parent method, <code>sing()</code>. Because the method is declared protected in the parent class,<br>\nit must be marked as <code>protected</code> or <code>public</code> in the child class. Even with abstract methods, the<br>\nrules for overriding methods must be followed.","children":[],"payload":{"tag":"li","lines":"289,306"}}],"payload":{"tag":"li","lines":"273,306"}}],"payload":{"tag":"li","lines":"262,306"}}],"payload":{"tag":"li","lines":"253,306"}}],"payload":{"tag":"li","lines":"240,306"}}],"payload":{"tag":"li","lines":"234,306"}}],"payload":{"tag":"li","lines":"228,306"}}],"payload":{"tag":"li","lines":"211,306"}},{"content":"While it is not possible to declare a method <code>abstract</code> and <code>private</code>, it is possible to<br>\ndeclare a method <code>final</code> and <code>private</code>.","children":[{"content":"<strong><code>abstract</code> and <code>static</code> Modifiers</strong><br>\nA <code>static</code> method can only be hidden, not overridden. If a <code>static</code> method<br>\ncannot be overridden, then it follows that it also cannot be marked<br>\n<code>abstract</code> since it can never be implemented. For example:<pre data-lines=\"312,317\"><code class=\"language-java\"><span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Hippopotamus</span> {\n  <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">swim</span><span class=\"hljs-params\">()</span>; <span class=\"hljs-comment\">// DOES NOT COMPILE</span>\n}\n</code></pre>","children":[],"payload":{"tag":"li","lines":"308,317"}}],"payload":{"tag":"li","lines":"306,317"}}],"payload":{"tag":"h1","lines":"5,6"}},{"initialExpandLevel":1})</script>
</body>
</html>
