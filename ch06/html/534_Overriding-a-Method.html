<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<title>Markmap</title>
<style>
* {
  margin: 0;
  padding: 0;
}
#mindmap {
  display: block;
  width: 100vw;
  height: 100vh;
}
</style>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@highlightjs/cdn-assets@11.11.1/styles/default.min.css">
</head>
<body>
<svg id="mindmap"></svg>
<script src="https://cdn.jsdelivr.net/npm/d3@7.9.0/dist/d3.min.js"></script><script src="https://cdn.jsdelivr.net/npm/markmap-view@0.18.10/dist/browser/index.js"></script><script src="https://cdn.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/index.js"></script><script>(r => {
              setTimeout(r);
            })(function renderToolbar() {
  const {
    markmap,
    mm
  } = window;
  const {
    el
  } = markmap.Toolbar.create(mm);
  el.setAttribute('style', 'position:absolute;bottom:20px;right:20px');
  document.body.append(el);
})</script><script>((getMarkmap, getOptions, root2, jsonOptions) => {
              const markmap = getMarkmap();
              window.mm = markmap.Markmap.create(
                "svg#mindmap",
                (getOptions || markmap.deriveOptions)(jsonOptions),
                root2
              );
            })(() => window.markmap,null,{"content":"<strong>Overriding a Method</strong>","children":[{"content":"Overriding a method occurs when a subclass declares a new implementation for<br>\nan inherited method with the same signature and compatible return type.","children":[{"content":"When you override a method, you may still reference the parent version of the method<br>\nusing the <code>super</code> keyword. In this manner, the keywords <code>this</code> and <code>super</code> allow you to<br>\nselect between the current and parent versions of a method, respectively. We illustrate<br>\nthis with the following example:","children":[{"content":"\n<pre data-lines=\"12,28\"><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Marsupial</span> {\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">double</span> <span class=\"hljs-title function_\">getAverageWeight</span><span class=\"hljs-params\">()</span> {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">50</span>;\n  }\n}\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Kangaroo</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">Marsupial</span> {\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">double</span> <span class=\"hljs-title function_\">getAverageWeight</span><span class=\"hljs-params\">()</span> {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">super</span>.getAverageWeight()+<span class=\"hljs-number\">20</span>;\n  }\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> {\n    <span class=\"hljs-type\">var</span> <span class=\"hljs-variable\">m</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Marsupial</span>().getAverageWeight();<span class=\"hljs-comment\">// 50.0</span>\n    <span class=\"hljs-type\">var</span> <span class=\"hljs-variable\">n</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Kangaroo</span>().getAverageWeight(); <span class=\"hljs-comment\">// 70.0</span>\n  }\n}\n</code></pre>","children":[{"content":"In this example, the <code>Kangaroo</code> class overrides the <code>getAverageWeight()</code> method<br>\nbut in the process calls the parent version using the <code>super</code> reference.","children":[],"payload":{"tag":"li","lines":"28,30"}},{"content":"<strong>Method Overriding Infinite Calls</strong><br>\nYou might be wondering whether the use of <code>super</code> in the previous example was<br>\nrequired. For example, what would the following code output if we removed the<br>\n<code>super</code> keyword?<pre data-lines=\"34,39\"><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">double</span> <span class=\"hljs-title function_\">getAverageWeight</span><span class=\"hljs-params\">()</span> {\n  <span class=\"hljs-keyword\">return</span> getAverageWeight()+<span class=\"hljs-number\">20</span>; <span class=\"hljs-comment\">// StackOverflowError</span>\n}\n</code></pre>\nIn this example, the compiler would not call the parent <code>Marsupial</code> method; it<br>\nwould call the current <code>Kangaroo</code> method. The application will attempt to call<br>\nitself infinitely and produce a <code>StackOverflowError</code> at runtime.","children":[{"content":"To override a method, you must follow a number of rules. The compiler performs<br>\nthe following checks when you override a method:","children":[{"content":"1. The method in the child class must have the same<br>\nsignature as the method in the parent class.","children":[],"payload":{"tag":"li","lines":"44,46","listIndex":1}},{"content":"2. The method in the child class must be at least as<br>\naccessible as the method in the parent class.","children":[],"payload":{"tag":"li","lines":"46,48","listIndex":2}},{"content":"3. The method in the child class may not declare a<br>\nchecked exception that is new or broader than the class<br>\nof any exception declared in the parent class method.","children":[],"payload":{"tag":"li","lines":"48,51","listIndex":3}},{"content":"4. If the method returns a value, it must be the same or a<br>\nsubtype of the method in the parent class, known as<br>\ncovariant return types.","children":[],"payload":{"tag":"li","lines":"51,54","listIndex":4}}],"payload":{"tag":"li","lines":"42,54"}}],"payload":{"tag":"li","lines":"30,54"}}],"payload":{"tag":"li","lines":"12,54"}}],"payload":{"tag":"li","lines":"8,54"}}],"payload":{"tag":"li","lines":"6,54"}},{"content":"<strong>Rule #1: Method Signatures</strong><br>\nThe first rule of overriding a method is somewhat self-explanatory. If two methods<br>\nhave the same name but different signatures, the methods are overloaded, not<br>\noverridden. Overloaded methods are not considered  polymorphic as overridden<br>\nmethods.","children":[{"content":"<strong>Rule #2: Access Modifiers</strong><br>\nIt must be equal or less restrictive in the child class.<pre data-lines=\"61,71\"><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Camel</span> {\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">getNumberOfHumps</span><span class=\"hljs-params\">()</span> {\n<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;\n} }\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">BactrianCamel</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">Camel</span> {\n<span class=\"hljs-keyword\">private</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">getNumberOfHumps</span><span class=\"hljs-params\">()</span> { <span class=\"hljs-comment\">// DOES NOT COMPILE</span>\n}<span class=\"hljs-keyword\">return</span>}\n<span class=\"hljs-number\">2</span>;\n</code></pre>","children":[{"content":"In this example, <code>BactrianCamel</code> attempts to override the <code>getNumberOfHumps()</code><br>\nmethod defined in the parent class but fails because the access modifier<br>\n<code>private</code> is more restrictive than the one defined in the parent version of the<br>\nmethod.","children":[{"content":"<strong>Rule #3: Checked Exceptions</strong><br>\nThe third rule says that overriding a method cannot declare new checked exceptions or<br>\nchecked exceptions broader than the inherited method.  One implication of this rule is<br>\nthat overridden methods are free to declare any number of new unchecked exceptions.","children":[{"content":"Let&#x2019;s try an example:<pre data-lines=\"80,92\"><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Reptile</span> {\n  <span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">sleep</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> IOException {}\n  <span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">hide</span><span class=\"hljs-params\">()</span> {}\n  <span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">exitShell</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> FileNotFoundException {}\n}\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">GalapagosTortoise</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">Reptile</span> {\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">sleep</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> FileNotFoundException {}\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">hide</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> FileNotFoundException {} <span class=\"hljs-comment\">// DOES NOT COMPILE</span>\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">exitShell</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> IOException {} <span class=\"hljs-comment\">//DOES NOT COMPILE</span>\n}\n</code></pre>","children":[{"content":"In this example, we have three overridden methods. These overridden methods use the more accessible<br>\n<code>public</code> modifier, which is allowed per our second rule for overridden methods. The first overridden method<br>\n<code>sleep()</code> in <code>GalapagosTortoise</code> compiles without issue because the declared exception is narrower than<br>\nthe exception declared in the parent class.","children":[],"payload":{"tag":"li","lines":"92,96"}},{"content":"The overridden <code>hide()</code> method does not compile because it declares a new checked exception not present<br>\nin the parent declaration. The overridden <code>exitShell()</code> also does not compile, since <code>IOException</code> is a broader<br>\nchecked exception than <code>FileNotFoundException</code>.","children":[],"payload":{"tag":"li","lines":"96,99"}}],"payload":{"tag":"li","lines":"79,99"}}],"payload":{"tag":"li","lines":"75,99"}}],"payload":{"tag":"li","lines":"71,99"}}],"payload":{"tag":"li","lines":"59,99"}}],"payload":{"tag":"li","lines":"54,99"}},{"content":"<strong>Rule #4: Covariant Return Types</strong><br>\nThe fourth and final rule around overriding a method is probably the most<br>\ncomplicated, as it requires knowing the relationships between the return<br>\ntypes. The overriding method must use a return type that is covariant with<br>\nthe return type of the inherited method.","children":[{"content":"Let&#x2019;s try an example for illustrative purposes:<pre data-lines=\"105,121\"><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Rhino</span> {\n  <span class=\"hljs-keyword\">protected</span> CharSequence <span class=\"hljs-title function_\">getName</span><span class=\"hljs-params\">()</span> {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;rhino&quot;</span>;\n  }\n  <span class=\"hljs-keyword\">protected</span> String <span class=\"hljs-title function_\">getColor</span><span class=\"hljs-params\">()</span> {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;grey, black, or white&quot;</span>;\n} }\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">JavanRhino</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">Rhino</span> {\n  <span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title function_\">getName</span><span class=\"hljs-params\">()</span> {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;javan rhino&quot;</span>;\n  }\n  <span class=\"hljs-keyword\">public</span> CharSequence <span class=\"hljs-title function_\">getColor</span><span class=\"hljs-params\">()</span> { <span class=\"hljs-comment\">// DOES NOT COMPILE</span>\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;grey&quot;</span>;\n} }\n</code></pre>","children":[{"content":"We learned that <code>String</code> implements the <code>CharSequence</code> interface, making <code>String</code> a subtype<br>\nof <code>CharSequence</code>. Therefore, the return type of <code>getName()</code> in <code>JavanRhino</code> is covariant<br>\nwith the return type of <code>getName()</code> in <code>Rhino</code>.<br>\nOn the other hand, the overridden <code>getColor()</code> method does not compile because<br>\n<code>CharSequence</code> is not a subtype of <code>String</code>. To put it another way, all <code>String</code> values are<br>\n<code>CharSequence</code> values, but not all <code>CharSequence</code> values are <code>String</code> values. For instance,<br>\na <code>StringBuilder</code> is a <code>CharSequence</code> but not a <code>String</code>. For the exam, you need to know if<br>\nthe return type of the overriding method is the same as or a subtype of the return type<br>\nof the inherited method.","children":[{"content":"<strong>Redeclaring private Methods</strong><br>\nyou can&#x2019;t override <code>private</code> methods since they are not inherited. Just because<br>\na child class doesn&#x2019;t have access to the parent method doesn&#x2019;t mean the child<br>\nclass can&#x2019;t define its own version of the method.<br>\nFor example, these two declarations compile:<pre data-lines=\"135,145\"><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Beetle</span> {\n  <span class=\"hljs-keyword\">private</span> String <span class=\"hljs-title function_\">getSize</span><span class=\"hljs-params\">()</span> {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;Undefined&quot;</span>;\n  } }\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">RhinocerosBeetle</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">Beetle</span> {\n  <span class=\"hljs-keyword\">private</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">getSize</span><span class=\"hljs-params\">()</span> {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">5</span>;\n  } }\n</code></pre>","children":[{"content":"Notice that the return type differs in the child method from <code>String</code> to <code>int</code>. In this example,<br>\nthe method <code>getSize()</code> in the parent class is not inherited, so the method in the child class<br>\nis a new method and not an override of the method in the parent class.<br>\nWhat if the <code>getSize()</code> method was declared <code>public</code> in <code>Beetle</code>? In this case, the method in<br>\n<code>RhinocerosBeetle</code> would be an invalid override. The access modifier in <code>RhinocerosBeetle</code><br>\nis more restrictive, and the return types are not covariant.","children":[{"content":"<strong>Hiding Static Methods</strong><br>\nA hidden method occurs when a child class defines a <code>static</code> method with the same name and signature as<br>\nan inherited <code>static</code> method defined in a parent class. Method hiding is similar to but not exactly the same<br>\nas method overriding. The previous four rules for overriding a method must be followed when a method is<br>\nhidden. In addition, a new fifth rule is added for hiding a method:<br>\n5. The method defined in the child class must be marked as <code>static</code> if it is marked as <code>static</code> in a parent class.","children":[],"payload":{"tag":"li","lines":"151,157"}}],"payload":{"tag":"li","lines":"145,157"}}],"payload":{"tag":"li","lines":"130,157"}}],"payload":{"tag":"li","lines":"121,157"}}],"payload":{"tag":"li","lines":"104,157"}}],"payload":{"tag":"li","lines":"99,157"}},{"content":"Put simply, <strong style=\"color:green\">it is method hiding if the two methods are marked <code>static</code> and<br>\nmethod overriding if they are not marked <code>static</code>. If one is marked <code>static</code><br>\nand the other is not, the class will not compile.</strong>","children":[{"content":"Let&#x2019;s review some examples of the new rule:<pre data-lines=\"161,174\"><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Bear</span> {\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">eat</span><span class=\"hljs-params\">()</span> {\n    System.out.println(<span class=\"hljs-string\">&quot;Bear is eating&quot;</span>);\n  } }\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Panda</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">Bear</span> {\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">eat</span><span class=\"hljs-params\">()</span> {\n    System.out.println(<span class=\"hljs-string\">&quot;Panda is chewing&quot;</span>);\n  }\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> {\n    eat();\n  } }\n</code></pre>","children":[{"content":"In this example, the code compiles and runs. The <code>eat()</code> method in the <code>Panda</code> class<br>\nhides the <code>eat()</code> method in the <code>Bear</code> class, printing <code>&quot;Panda is chewing&quot;</code> at runtime.<br>\nBecause they are both marked as <code>static</code>, this is not considered an overridden method.<br>\nThat said, there is still some inheritance going on. If you remove the <code>eat()</code> declaration<br>\nin the <code>Panda</code> class, then the program prints <code>&quot;Bear is eating&quot;</code> instead.","children":[{"content":"See if you can figure out why each of the method declarations<br>\nin the <code>SunBear</code> class does not compile:<pre data-lines=\"181,205\"><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Bear</span> {\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">sneeze</span><span class=\"hljs-params\">()</span> {\n    System.out.println(<span class=\"hljs-string\">&quot;Bear is sneezing&quot;</span>);\n  }\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">hibernate</span><span class=\"hljs-params\">()</span> {\n    System.out.println(<span class=\"hljs-string\">&quot;Bear is hibernating&quot;</span>);\n  }\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">laugh</span><span class=\"hljs-params\">()</span> {\n    System.out.println(<span class=\"hljs-string\">&quot;Bear is laughing&quot;</span>);\n  }\n}\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">SunBear</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">Bear</span> {\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">sneeze</span><span class=\"hljs-params\">()</span> { <span class=\"hljs-comment\">// DOES NOT COMPILE</span>\n    System.out.println(<span class=\"hljs-string\">&quot;Sun Bear sneezes quietly&quot;</span>);\n  }\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">hibernate</span><span class=\"hljs-params\">()</span> { <span class=\"hljs-comment\">// DOES NOT COMPILE</span>\n    System.out.println(<span class=\"hljs-string\">&quot;Sun Bear is going to sleep&quot;</span>);\n  }\n  <span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">laugh</span><span class=\"hljs-params\">()</span> { <span class=\"hljs-comment\">// DOES NOT COMPILE</span>\n    System.out.println(<span class=\"hljs-string\">&quot;Sun Bear is laughing&quot;</span>);\n  }\n}\n</code></pre>","children":[{"content":"In this example, <code>sneeze()</code> is marked <code>static</code> in the parent class but not in the child class.<br>\nThe compiler detects that you&#x2019;re trying to override using an instance method. However,<br>\n<code>sneeze()</code> is a <code>static</code> method that should be hidden, causing the compiler to generate an<br>\nerror. The second method, <code>hibernate()</code>, does not compile for the opposite reason. The<br>\nmethod is marked <code>static</code> in the child class but not in the parent class.","children":[],"payload":{"tag":"li","lines":"205,210"}},{"content":"Finally, the <code>laugh()</code> method does not compile. Even though both versions of the method<br>\nare marked <code>static</code>, the version in <code>SunBear</code> has a more restrictive access modifier than<br>\nthe one it inherits, and it breaks the second rule for overriding methods. Remember, the<br>\nfour rules for overriding methods must be followed when hiding <code>static</code> methods.","children":[{"content":"<strong>Hiding Variables</strong><br>\nJava doesn&#x2019;t allow variables to be overridden. Variables can be hidden, though.<br>\nA hidden variable occurs when a child class defines a variable with the same name as an inherited variable<br>\ndefined in the parent class. This creates two distinct copies of the variable within an instance of the child<br>\nclass: one instance defined in the parent class and one defined in the child class.","children":[],"payload":{"tag":"li","lines":"214,219"}}],"payload":{"tag":"li","lines":"210,219"}}],"payload":{"tag":"li","lines":"179,219"}}],"payload":{"tag":"li","lines":"174,219"}}],"payload":{"tag":"li","lines":"160,219"}}],"payload":{"tag":"li","lines":"157,219"}},{"content":"What do you think the following application<br>\nprints?<pre data-lines=\"221,235\"><code class=\"language-java\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Carnivore</span> {\n  <span class=\"hljs-keyword\">protected</span> <span class=\"hljs-type\">boolean</span> <span class=\"hljs-variable\">hasFur</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">false</span>;\n}\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Meerkat</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">Carnivore</span> {\n  <span class=\"hljs-keyword\">protected</span> <span class=\"hljs-type\">boolean</span> <span class=\"hljs-variable\">hasFur</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">true</span>;\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> {\n    <span class=\"hljs-type\">Meerkat</span> <span class=\"hljs-variable\">m</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Meerkat</span>();\n    <span class=\"hljs-type\">Carnivore</span> <span class=\"hljs-variable\">c</span> <span class=\"hljs-operator\">=</span> m;\n    System.out.println(m.hasFur); <span class=\"hljs-comment\">//true</span>\n    System.out.println(c.hasFur); <span class=\"hljs-comment\">//false</span>\n  }\n}\n</code></pre>","children":[{"content":"Confused about the output? Both of these classes define a <code>hasFur</code> variable, but<br>\nwith different values. Even though only one object is created by the <code>main()</code> method,<br>\nboth variables exist independently of each other. <strong>The output changes depending<br>\non the reference variable used.</strong><br>\nIf you didn&#x2019;t understand the last example, don&#x2019;t worry. For now, you just need to<br>\nknow that overriding a method replaces the parent method on all reference variables<br>\n(other than <code>super</code>), whereas hiding a method or variable replaces the member<br>\nonly if a child reference type is used.","children":[{"content":"<strong>Writing <em><code>final</code></em> Methods</strong><br>\n<code>final</code> methods cannot be overridden or hidden.  Let&#x2019;s take a look at an example:<pre data-lines=\"245,259\"><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Bird</span> {\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">boolean</span> <span class=\"hljs-title function_\">hasFeathers</span><span class=\"hljs-params\">()</span> {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\n  }\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">flyAway</span><span class=\"hljs-params\">()</span> {}\n}\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Penguin</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">Bird</span> {\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">boolean</span> <span class=\"hljs-title function_\">hasFeathers</span><span class=\"hljs-params\">()</span> { <span class=\"hljs-comment\">// DOES NOT COMPILE</span>\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\n  }\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">flyAway</span><span class=\"hljs-params\">()</span> {} <span class=\"hljs-comment\">// DOES NOT COMPILE</span>\n}\n</code></pre>","children":[{"content":"In this example, the instance method <code>hasFeathers()</code> is marked as final in the parent class<br>\n<code>Bird</code>, so the child class <code>Penguin</code> cannot override the parent method, resulting in a compiler<br>\nerror. The static method <code>flyAway()</code> is also marked <code>final</code>, so it cannot be hidden in the<br>\nsubclass. In this example, whether or not the child method uses the <code>final</code> keyword is<br>\nirrelevant; the code will not compile either way.<br>\nThis rule applies only to inherited methods. For example, if the two methods were marked<br>\n<code>private</code> in the parent <code>Bird</code> class, then the <code>Penguin</code> class, as defined, would compile. In<br>\nthat case, the private methods would be redeclared, not overridden or hidden.","children":[],"payload":{"tag":"li","lines":"259,267"}}],"payload":{"tag":"li","lines":"243,267"}}],"payload":{"tag":"li","lines":"235,267"}}],"payload":{"tag":"li","lines":"219,267"}}],"payload":{"tag":"h1","lines":"5,6"}},{"initialExpandLevel":1})</script>
</body>
</html>
