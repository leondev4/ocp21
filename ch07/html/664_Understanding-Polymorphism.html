<!doctype html>
<html>
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta http-equiv="X-UA-Compatible" content="ie=edge" />
<title>Markmap</title>
<style>
* {
  margin: 0;
  padding: 0;
}
html {
  font-family: ui-sans-serif, system-ui, sans-serif, 'Apple Color Emoji',
    'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji';
}
#mindmap {
  display: block;
  width: 100vw;
  height: 100vh;
}
.markmap-dark {
  background: #27272a;
  color: white;
}
</style>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/markmap-toolbar@0.18.12/dist/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@highlightjs/cdn-assets@11.11.1/styles/default.min.css">
</head>
<body>
<svg id="mindmap"></svg>
<script src="https://cdn.jsdelivr.net/npm/d3@7.9.0/dist/d3.min.js"></script><script src="https://cdn.jsdelivr.net/npm/markmap-view@0.18.12/dist/browser/index.js"></script><script src="https://cdn.jsdelivr.net/npm/markmap-toolbar@0.18.12/dist/index.js"></script><script>(r => {
              setTimeout(r);
            })(function renderToolbar() {
  const {
    markmap,
    mm
  } = window;
  const {
    el
  } = markmap.Toolbar.create(mm);
  el.setAttribute('style', 'position:absolute;bottom:20px;right:20px');
  document.body.append(el);
})</script><script>((getMarkmap, getOptions, root2, jsonOptions) => {
              const markmap = getMarkmap();
              window.mm = markmap.Markmap.create(
                "svg#mindmap",
                (getOptions || markmap.deriveOptions)(jsonOptions),
                root2
              );
              if (window.matchMedia("(prefers-color-scheme: dark)").matches) {
                document.documentElement.classList.add("markmap-dark");
              }
            })(() => window.markmap,null,{"content":"<strong>Understanding Polymorphism</strong>","children":[{"content":"Polymorphism is the property of an object to take on many different forms. To<br>\nput this more precisely, a Java object may be accessed using the following:<br>\n* A reference with the same type as the object<br>\n* A reference that is a superclass of the object<br>\n* A reference of an interface the object implements or inherits<br>\n<strong>A cast is not required if the object is being reassigned to a supertype<br>\nor interface of the object.</strong>","children":[{"content":"Let&#x2019;s illustrate this polymorphism property with the following example:<pre data-lines=\"14,35\"><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Primate</span> {\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">boolean</span> <span class=\"hljs-title function_\">hasHair</span><span class=\"hljs-params\">()</span> { <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>; }\n}\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">HasTail</span> {\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-type\">boolean</span> <span class=\"hljs-title function_\">isTailStriped</span><span class=\"hljs-params\">()</span>;\n}\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Lemur</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">Primate</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">HasTail</span> {\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">boolean</span> <span class=\"hljs-title function_\">isTailStriped</span><span class=\"hljs-params\">()</span> { <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>; }\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">age</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">10</span>;\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> {\n    <span class=\"hljs-type\">Lemur</span> <span class=\"hljs-variable\">lemur</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Lemur</span>();\n    System.out.println(lemur.age);\n\n    <span class=\"hljs-type\">HasTail</span> <span class=\"hljs-variable\">hasTail</span> <span class=\"hljs-operator\">=</span> lemur;\n    System.out.println(hasTail.isTailStriped());\n\n    <span class=\"hljs-type\">Primate</span> <span class=\"hljs-variable\">primate</span> <span class=\"hljs-operator\">=</span> lemur;\n    System.out.println(primate.hasHair());\n} }\n</code></pre>","children":[{"content":"This code compiles and prints the following output:<br>\n<code>10</code><br>\n<code>false</code><br>\n<code>true</code><br>\nThe most important thing to note about this example is that only one object, <code>Lemur</code>, is created.<br>\nPolymorphism enables an instance of <code>Lemur</code> to be reassigned or passed to a method using<br>\none of its supertypes, such as <code>Primate</code> or <code>HasTail</code>.","children":[{"content":"Once the object has been assigned to a new reference type, only the methods<br>\nand variables available to that reference type are callable on the object without<br>\nan explicit cast. For example, the following snippets of code will not compile:<pre data-lines=\"45,52\"><code class=\"language-java\"><span class=\"hljs-type\">HasTail</span> <span class=\"hljs-variable\">hasTail</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Lemur</span>();\nSystem.out.println(hasTail.age); <span class=\"hljs-comment\">// DOES NOT COMPILE</span>\n\n<span class=\"hljs-type\">Primate</span> <span class=\"hljs-variable\">primate</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Lemur</span>();\nSystem.out.println(primate.isTailStriped()); <span class=\"hljs-comment\">// DOES NOT COMPILE</span>\n</code></pre>","children":[{"content":"In this example, the reference <code>hasTail</code> has direct access only to methods defined with the<br>\n<code>HasTail</code> interface;  therefore, it doesn&#x2019;t know that the variable <code>age</code> is part of the object.<br>\nLikewise, the reference <code>primate</code> has  access only to methods defined in the <code>Primate</code> class,<br>\nand it doesn&#x2019;t have direct access to the <code>isTailStriped()</code> method.","children":[{"content":"<strong>Object vs. Reference</strong><br>\nIn Java, all objects are accessed by reference, so as a developer you never have direct access<br>\nto the object itself. Conceptually, though, you should consider the object as the entity that exists<br>\nin memory, allocated by the Java. Regardless of the type of the reference you have for the  object<br>\nin memory, the object itself doesn&#x2019;t change. For example, since all objects inherit  <code>java.lang.Object</code>,<br>\nthey can all be reassigned to <code>java.lang.Object</code>, as shown in the following example:<pre data-lines=\"62,66\"><code class=\"language-java\"><span class=\"hljs-type\">Lemur</span> <span class=\"hljs-variable\">lemur</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Lemur</span>();\n<span class=\"hljs-type\">Object</span> <span class=\"hljs-variable\">lemurAsObject</span> <span class=\"hljs-operator\">=</span> lemur;\n</code></pre>","children":[{"content":"Even though the <code>Lemur</code> object has been assigned to a reference with a different type, the object<br>\nitself has not changed and still exists as a <code>Lemur</code> object in memory. What has changed, then, is<br>\nour ability to access methods within the <code>Lemur</code> class with the <code>lemurAsObject</code> reference. Without<br>\nan explicit cast back to <code>Lemur</code>, as you see in the next section, we no longer have access to the<br>\n<code>Lemur</code> properties of the object.","children":[{"content":"We can summarize this principle with the following two rules:<br>\n1.- The type of the object determines which properties exist within the object in memory.<br>\n2.- The type of the reference to the object determines which methods and variables are<br>\naccessible to the Java program.","children":[],"payload":{"tag":"li","lines":"71,75"}}],"payload":{"tag":"li","lines":"66,75"}}],"payload":{"tag":"li","lines":"56,75"}}],"payload":{"tag":"li","lines":"52,75"}}],"payload":{"tag":"li","lines":"42,75"}}],"payload":{"tag":"li","lines":"35,75"}}],"payload":{"tag":"li","lines":"13,75"}}],"payload":{"tag":"li","lines":"6,75"}},{"content":"It therefore follows that successfully changing a reference of an object to a new<br>\nreference type may give you access to new properties of the object; but remember,<br>\nthose properties existed before the reference change occurred. Using the <code>Lemur</code><br>\nexample, we illustrate this property in <a href=\"https://1drv.ms/i/c/c83cfca51d5c2032/EWZvi2szmhxKiZ8gNuzXibYB73fjewbJKMKoP80gn5xp_A?e=VaazGA\">Figure 7.8</a>.","children":[{"content":"As you can see in the figure, the same object exists in memory regardless of which<br>\nreference is pointing to it. Depending on the type of the reference, we may only have<br>\naccess to certain methods. For example, the <code>hasTail</code> reference has access to the<br>\nmethod <code>isTailStriped()</code> but doesn&#x2019;t have access to the variable <code>age</code> defined in the<br>\n<code>Lemur</code> class.","children":[{"content":"<strong>Casting Objects</strong><br>\nIn the previous example, we created a single instance of a <code>Lemur</code> object and accessed it via<br>\nsuperclass and interface references. Once we changed the reference type, though, we lost<br>\naccess to more specific members defined in the subclass that still exist within the object. We<br>\ncan reclaim those references by casting the object back to the specific subclass it came from:<pre data-lines=\"89,95\"><code class=\"language-java\"><span class=\"hljs-type\">Lemur</span> <span class=\"hljs-variable\">lemur</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Lemur</span>();\n<span class=\"hljs-type\">Primate</span> <span class=\"hljs-variable\">primate</span> <span class=\"hljs-operator\">=</span> lemur; <span class=\"hljs-comment\">// Implicit Cast to supertype</span>\n<span class=\"hljs-type\">Lemur</span> <span class=\"hljs-variable\">lemur2</span> <span class=\"hljs-operator\">=</span> (Lemur)primate; <span class=\"hljs-comment\">// Explicit Cast to subtype</span>\n<span class=\"hljs-type\">Lemur</span> <span class=\"hljs-variable\">lemur3</span> <span class=\"hljs-operator\">=</span> primate; <span class=\"hljs-comment\">// DOES NOT COMPILE (missing cast)</span>\n</code></pre>","children":[{"content":"In this example, we first create a <code>Lemur</code> object and implicitly cast it to a <code>Primate</code> reference.<br>\nSince <code>Lemur</code> is a subtype of <code>Primate</code>, this can be done without a cast operator. We then<br>\ncast it back to a <code>Lemur</code> object using an explicit cast, gaining access to all of the methods<br>\nand fields in the <code>Lemur</code> class. The last line does not compile because an explicit cast is<br>\nrequired. Even though the object is stored in memory as a <code>Lemur</code> object, we need an<br>\nexplicit cast to assign it to <code>Lemur</code>.","children":[{"content":"When casting objects, you do not need a cast operator if casting to an inherited supertype.<br>\nThis is referred to as an implicit cast and applies to classes or interfaces the object inherits.<br>\nAlternatively, if you want to access a subtype of the current reference, you need to perform<br>\nan explicit cast with a compatible type. If the underlying object is not compatible with the<br>\ntype, then a <code>ClassCastException</code> will be thrown at runtime.","children":[{"content":"We summarize these concepts into a set of rules for you to memorize for the exam:<br>\n1.- Casting a reference from a subtype to a supertype doesn&#x2019;t require an explicit cast.<br>\n2.- Casting a reference from a supertype to a subtype requires an explicit cast.<br>\n3.- At runtime, an invalid cast of a reference to an incompatible type results in a<br>\n<code>ClassCastException</code> being thrown.<br>\n4.- The compiler disallows casts to unrelated types.","children":[{"content":"<strong>Disallowed Casts</strong><br>\nThe first three rules are just a review of what we&#x2019;ve said so far. The last rule is a bit more<br>\ncomplicated.  The exam may try to trick you with a cast that the compiler knows is not<br>\npermitted (aka impossible). In the previous example, we were able to cast a <code>Primate</code><br>\nreference to a <code>Lemur</code> reference because <code>Lemur</code> is a subclass of <code>Primate</code> and therefore<br>\nrelated. Consider this example instead:<pre data-lines=\"118,127\"><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Bird</span> {}\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Fish</span> {\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> {\n    <span class=\"hljs-type\">Fish</span> <span class=\"hljs-variable\">fish</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Fish</span>();\n    <span class=\"hljs-type\">Bird</span> <span class=\"hljs-variable\">bird</span> <span class=\"hljs-operator\">=</span> (Bird)fish; <span class=\"hljs-comment\">// DOES NOT COMPILE</span>\n  }\n}\n</code></pre>","children":[{"content":"In this example, the classes <code>Fish</code> and <code>Bird</code> are not related through any class<br>\nhierarchy that the compiler is aware of; therefore, the code will not compile.<br>\nWhile they both extend <code>Object</code> implicitly, they are considered unrelated types<br>\nsince one cannot be a subtype of the other.","children":[],"payload":{"tag":"li","lines":"127,131"}}],"payload":{"tag":"li","lines":"112,131"}}],"payload":{"tag":"li","lines":"106,131"}}],"payload":{"tag":"li","lines":"101,131"}}],"payload":{"tag":"li","lines":"95,131"}}],"payload":{"tag":"li","lines":"84,131"}}],"payload":{"tag":"li","lines":"79,131"}}],"payload":{"tag":"li","lines":"75,131"}},{"content":"<strong>Casting Interfaces</strong><br>\nWhile the compiler can enforce rules about casting to unrelated types for classes,<br>\nit  cannot always do the same for interfaces. Remember, interfaces support multiple<br>\ninheritance, which limits what the compiler can reason about them. While a given<br>\nclass may not implement an interface, it&#x2019;s possible that some subclass may<br>\nimplement the interface. When holding a reference to a particular class, the compiler<br>\ndoesn&#x2019;t know which specific subtype it is holding.","children":[{"content":"Example<pre data-lines=\"139,150\"><code class=\"language-java\"><span class=\"hljs-number\">1</span>: <span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">Canine</span> {}\n<span class=\"hljs-number\">2</span>: <span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">Dog</span> {}\n<span class=\"hljs-number\">3</span>: <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Wolf</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">Canine</span> {}\n<span class=\"hljs-number\">4</span>:\n<span class=\"hljs-number\">5</span>: <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">BadCasts</span> {\n<span class=\"hljs-number\">6</span>:   <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> {\n<span class=\"hljs-number\">7</span>:     <span class=\"hljs-type\">Wolf</span> <span class=\"hljs-variable\">wolfy</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Wolf</span>();\n<span class=\"hljs-number\">8</span>:     <span class=\"hljs-type\">Dog</span> <span class=\"hljs-variable\">badWolf</span> <span class=\"hljs-operator\">=</span> (Dog)wolfy;\n<span class=\"hljs-number\">9</span>:   } }\n</code></pre>","children":[{"content":"In this program, a <code>Wolf</code> object is created and then assigned to a <code>Wolf</code> reference type on line 7.<br>\nWith interfaces, the compiler has limited ability to enforce many rules because even though a<br>\nreference type may not implement an interface, one of its subclasses could. Therefore, it allows<br>\nthe invalid cast to the <code>Dog</code> reference type on line 8, even though <code>Dog</code> and <code>Wolf</code> are not related.<br>\nFear not, even though the code compiles, it still throws a <code>ClassCastException</code> at runtime.","children":[{"content":"This limitation aside, the compiler can enforce one rule around interface casting. The compiler<br>\ndoes not allow a cast from an interface reference to an object reference if the object type<br>\ncannot possibly implement the interface, such as if the class is marked <code>final</code>. For example,<br>\nwhat if we changed line 3 of our previous code?<pre data-lines=\"159,162\"><code class=\"language-java\"><span class=\"hljs-number\">3</span>: <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Wolf</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">Canine</span> {}\n</code></pre>\nLine 8 no longer compiles. The compiler recognizes that there are no possible subclasses of<br>\n<code>Wolf</code> capable of implementing the <code>Dog</code> interface.","children":[{"content":"<strong>The instanceof <code>Operator</code></strong><br>\nThe <code>instanceof</code> operator can be used to check whether an object belongs to a particular class  or<br>\ninterface and to prevent a <code>ClassCastException</code> at runtime. It can also be used with pattern matching.","children":[{"content":"Consider the following example:<pre data-lines=\"168,178\"><code class=\"language-java\"><span class=\"hljs-number\">1</span>: <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Rodent</span> {}\n<span class=\"hljs-number\">2</span>:\n<span class=\"hljs-number\">3</span>: <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Capybara</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">Rodent</span> {\n<span class=\"hljs-number\">4</span>:   <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> {\n<span class=\"hljs-number\">5</span>:     <span class=\"hljs-type\">Rodent</span> <span class=\"hljs-variable\">rodent</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Rodent</span>();\n<span class=\"hljs-number\">6</span>:     <span class=\"hljs-type\">var</span> <span class=\"hljs-variable\">capybara</span> <span class=\"hljs-operator\">=</span> (Capybara)rodent; <span class=\"hljs-comment\">// ClassCastException</span>\n<span class=\"hljs-number\">7</span>:   }\n<span class=\"hljs-number\">8</span>: }\n</code></pre>","children":[{"content":"This program throws an exception on line 6. We can replace line 6 with the following:<pre data-lines=\"179,184\"><code class=\"language-java\"><span class=\"hljs-number\">6</span>:    <span class=\"hljs-keyword\">if</span>(rodent <span class=\"hljs-keyword\">instanceof</span> Capybara c) {\n<span class=\"hljs-number\">7</span>:        <span class=\"hljs-comment\">// Do stuff</span>\n<span class=\"hljs-number\">8</span>:    }\n</code></pre>\nNow the code snippet doesn&#x2019;t throw an exception at runtime and performs the cast only<br>\nif the <code>instanceof</code> operator is successful.","children":[{"content":"Just as the compiler does not allow casting an object to unrelated<br>\ntypes, it also does not allow <code>instanceof</code> to be used with unrelated<br>\ntypes. We can demonstrate this with our unrelated <code>Bird</code> and <code>Fish</code><br>\nclasses:<pre data-lines=\"190,200\"><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Bird</span> {}\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Fish</span> {\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> {\n    <span class=\"hljs-type\">Fish</span> <span class=\"hljs-variable\">fish</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Fish</span>();\n    <span class=\"hljs-keyword\">if</span> (fish <span class=\"hljs-keyword\">instanceof</span> Bird b) { <span class=\"hljs-comment\">// DOES NOT COMPILE</span>\n        <span class=\"hljs-comment\">// Do stuff</span>\n    } } }\n</code></pre>","children":[],"payload":{"tag":"li","lines":"186,200"}}],"payload":{"tag":"li","lines":"178,200"}}],"payload":{"tag":"li","lines":"167,200"}}],"payload":{"tag":"li","lines":"164,200"}}],"payload":{"tag":"li","lines":"155,200"}}],"payload":{"tag":"li","lines":"150,200"}}],"payload":{"tag":"li","lines":"138,200"}}],"payload":{"tag":"li","lines":"131,200"}},{"content":"<strong>Polymorphism and Method Overriding</strong><br>\nIn Java, polymorphism states that <mark>when you override a method, you replace all calls<br>\nto it, even those defined in the parent class.</mark> As an example, what do you think the<br>\nfollowing code snippet outputs?<pre data-lines=\"204,216\"><code class=\"language-java\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Penguin</span> {\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">getHeight</span><span class=\"hljs-params\">()</span> { <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">3</span>; }\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">printInfo</span><span class=\"hljs-params\">()</span> {\n    System.out.print(<span class=\"hljs-built_in\">this</span>.getHeight());\n  } }\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">EmperorPenguin</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">Penguin</span> {\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">getHeight</span><span class=\"hljs-params\">()</span> { <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">8</span>; }\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String []fish)</span> {\n    <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">EmperorPenguin</span>().printInfo();\n  } }\n</code></pre>","children":[{"content":"If you said <code>8</code>, then you are well on your way to understanding polymorphism. In this<br>\nexample, the object being operated on in memory is an <code>EmperorPenguin</code>. The<br>\n<code>getHeight()</code> method is overridden in the subclass, meaning all calls to it are replaced<br>\nat runtime. Despite <code>printInfo()</code> being defined in the <code>Penguin</code> class, <mark>calling <code>getHeight()</code><br>\non the object calls the method associated with the precise object in memory,</mark> not the<br>\ncurrent reference type where it is called. Even using the <code>this</code> reference, which is<br>\noptional in this example, <mark>does not call the parent version because the method has<br>\nbeen replaced.</mark>","children":[{"content":"Polymorphism&#x2019;s ability to replace methods at runtime via overriding is one of the most<br>\nimportant properties of Java. It allows you to create complex inheritance models with<br>\nsubclasses that have their own custom implementation of overridden methods. It also<br>\nmeans the parent class does not need to be updated to use the custom or overridden<br>\nmethod. If the method is properly overridden, then <mark>the overridden version will be used<br>\nin all places that it is called.</mark><br>\nRemember, you can choose to limit polymorphic behavior by marking methods <code>final</code>,<br>\nwhich prevents them from being overridden by a subclass.","children":[{"content":"<strong>Calling the Parent Version of an Overridden Method</strong><br>\nJust because a method is overridden doesn&#x2019;t mean the parent method is completely<br>\ninaccessible. We can use the <code>super</code> reference to access it. How can you modify our<br>\nprevious example to print <code>3</code> instead of <code>8</code>? You could try calling <code>super.getHeight()</code><br>\nin the parent <code>Penguin</code> class:<pre data-lines=\"237,245\"><code class=\"language-java\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Penguin</span> {\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">getHeight</span><span class=\"hljs-params\">()</span> { <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">3</span>; }\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">printInfo</span><span class=\"hljs-params\">()</span> {\n    System.out.print(<span class=\"hljs-built_in\">super</span>.getHeight()); <span class=\"hljs-comment\">// DOES NOT COMPILE</span>\n  }\n}\n</code></pre>","children":[{"content":"Unfortunately, this does not compile, as <code>super</code> refers to the superclass of <code>Penguin</code>;<br>\nin this case, <code>Object</code>. The solution is to override <code>printInfo()</code> in the child <code>EmperorPenguin</code><br>\nclass and use <code>super</code> there.<pre data-lines=\"248,259\"><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">EmperorPenguin</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">Penguin</span> {\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">getHeight</span><span class=\"hljs-params\">()</span> { <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">8</span>; }\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">printInfo</span><span class=\"hljs-params\">()</span> {\n    System.out.print(<span class=\"hljs-built_in\">super</span>.getHeight());\n  }\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String []fish)</span> {\n    <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">EmperorPenguin</span>().printInfo(); <span class=\"hljs-comment\">// 3</span>\n  }\n}\n</code></pre>","children":[{"content":"<strong>Overriding vs. Hiding Members</strong><br>\nWhile method overriding replaces the method everywhere it is called, <code>static</code> method<br>\nand variable hiding do not. Strictly speaking, hiding members is not a form of<br>\npolymorphism since the methods and variables maintain their individual properties.<br>\nUnlike method overriding, <mark>hiding members is very sensitive to the reference type<br>\nand location where the member is being used.</mark>","children":[{"content":"Let&#x2019;s take a look at an example:<pre data-lines=\"266,278\"><code class=\"language-java\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Penguin</span> {\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">getHeight</span><span class=\"hljs-params\">()</span> { <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">3</span>; }\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">printInfo</span><span class=\"hljs-params\">()</span> {\n    System.out.println(<span class=\"hljs-built_in\">this</span>.getHeight());\n  } }\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">CrestedPenguin</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">Penguin</span> {\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">getHeight</span><span class=\"hljs-params\">()</span> { <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">8</span>; }\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String&#x2026; fish)</span> {\n    <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">CrestedPenguin</span>().printInfo();\n  } }\n</code></pre>","children":[{"content":"The <code>CrestedPenguin</code> example is nearly identical to our previous <code>EmperorPenguin</code> example,<br>\nalthough as you probably already guessed, it prints <code>3</code> instead of <code>8</code>. The <code>getHeight()</code><br>\nmethod is <code>static</code> and is therefore hidden, not overridden.<br>\nThe result is that calling <code>getHeight()</code> in <code>CrestedPenguin</code> returns a different value than calling<br>\nit in <code>Penguin</code>, even if the underlying object is the same. Contrast this with overriding a method,<br>\nwhere it returns the same value for an object regardless of which class it is called in.","children":[],"payload":{"tag":"li","lines":"278,284"}}],"payload":{"tag":"li","lines":"265,284"}}],"payload":{"tag":"li","lines":"259,284"}}],"payload":{"tag":"li","lines":"245,284"}}],"payload":{"tag":"li","lines":"232,284"}}],"payload":{"tag":"li","lines":"224,284"}}],"payload":{"tag":"li","lines":"216,284"}}],"payload":{"tag":"li","lines":"200,284"}},{"content":"What about the fact that we used <code>this</code> to access a <code>static</code> method in <code>this.getHeight()</code>?<br>\nWhile you are permitted to use an instance reference to access a <code>static</code> variable or<br>\nmethod, doing so is often discouraged. The compiler will warn you when you access<br>\n<code>static</code> members in a non-<code>static</code> way. In this case, the <code>this</code> reference had no impact<br>\non the program output.","children":[{"content":"Besides the location, the reference type can also determine<br>\nthe value you get when you are working with hidden<br>\nmembers. Ready? Let&#x2019;s try a more complex example:<pre data-lines=\"292,309\"><code class=\"language-java\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Marsupial</span> {\n  <span class=\"hljs-keyword\">protected</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">age</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">2</span>;\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">boolean</span> <span class=\"hljs-title function_\">isBiped</span><span class=\"hljs-params\">()</span> { <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;} \n}\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Kangaroo</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">Marsupial</span> {\n  <span class=\"hljs-keyword\">protected</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">age</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">6</span>;\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">boolean</span> <span class=\"hljs-title function_\">isBiped</span><span class=\"hljs-params\">()</span> { <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>; }\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> {\n    <span class=\"hljs-type\">Kangaroo</span> <span class=\"hljs-variable\">joey</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Kangaroo</span>();\n    <span class=\"hljs-type\">Marsupial</span> <span class=\"hljs-variable\">moey</span> <span class=\"hljs-operator\">=</span> joey;\n    System.out.println(joey.isBiped());\n    System.out.println(moey.isBiped());\n    System.out.println(joey.age);\n    System.out.println(moey.age);\n  } }\n</code></pre>","children":[{"content":"The program prints the following:<pre data-lines=\"310,316\"><code class=\"language-java\"><span class=\"hljs-literal\">true</span>\n<span class=\"hljs-literal\">false</span>\n<span class=\"hljs-number\">6</span>\n<span class=\"hljs-number\">2</span>\n</code></pre>","children":[{"content":"In this example, only one object (of type <code>Kangaroo</code>) is created and stored in memory!<br>\nSince <code>static</code> methods can only be hidden, not overridden, <mark>Java uses the reference type<br>\nto determine which version of <code>isBiped()</code> should be called,</mark> resulting in <code>joey.isBiped()</code><br>\nprinting true and <code>moey.isBiped()</code> printing <code>false</code>.<br>\nLikewise, the <code>age</code> variable is hidden, not overridden, so the reference type is used to<br>\ndetermine which value to output. This results in <code>joey.age</code> returning <code>6</code> and <code>moey.age</code><br>\nreturning <code>2</code>.","children":[],"payload":{"tag":"li","lines":"316,323"}}],"payload":{"tag":"li","lines":"309,323"}}],"payload":{"tag":"li","lines":"289,323"}}],"payload":{"tag":"li","lines":"284,323"}}],"payload":{"tag":"h1","lines":"5,6"}},{"initialExpandLevel":1})</script>
</body>
</html>
